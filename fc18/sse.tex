\documentclass[]{llncs}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
\graphicspath{{./figures/}}
\usepackage{subcaption}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{standalone}
\usepackage{pgfplots}
%% The amsthm package provides extended theorem environments
%\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}

\usepackage{listings}

\usepackage{hyperref}

\usepackage{systeme}

\usepackage{enumitem}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1\textcolor{blue}{ #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes:}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{red}{Dima notes:}}{#1}}}
\newcommand{\vk}[1]{{\authnote{\textcolor{red}{V:}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\pgfplotsset{compat=newest, table/search path=figures}

\begin{document}

\title{A Systematic Approach To Cryptocurrency Fees}

%\title{On Space-Scarce Economy\\ In Blockchain Systems}

%\author{Alexander Chepurnoy \and Vasily Kharin \and Dmitry Meshkov}
%\institute{IOHK Research}
\maketitle

\begin{abstract}

In this paper we study space-scarce economy in massively replicated open
blockchain systems. In these systems, such as Bitcoin, memory to hold a current
state snapshot needed to validate transactions becomes the most scarce resource
eventually. The issue is even more critical for blockchain systems used to store
data~(votes, certificates, logs etc.). Uncontrolled state size growth could lead
to security issues, such as denial-of-service attacks. Only technical solutions,
not economic, have been proposed to tackle this problem to the moment. In
contrast, we propose to add a new component to a transaction fee scheme based on
how much additional space will be needed for new objects created in result of
transaction processing and for how long they will live in the state. \knote{write abt fee adjustment rule} 
%We provide three possible options towards implementing the new fee component, namely
%\textit{prepaid outputs}, \textit{postpaid outputs} and \textit{scheduled
%payments}. We provide an analysis of the model with respect to all the three
%options.
\knote{rewrite further} 
 We show that the state growth could be bounded by a fee factor, miners
are getting additional stable rewards and lost coins are being taken back into
circulation eventually.    \knote{check this}

\end{abstract}

\section{Introduction}

Bitcoin~\cite{Nakamoto2008} was introduced in 2008 by S. Nakamoto as a purely
peer-to-peer version of electronic cash with a ledger written into blockchain
data structure securely replicated by each network node. Security of the scheme
is relied on mining process. If majority of miners are honest, then Bitcoin
meets its security goals as formal analysis~\cite{Garay2015} shows. For work
done a miner is claiming a reward which consists of two parts. First, some
constant number of bitcoins are created out of thin air according to a
predefined and hard-coded token emission schedule. Second, a miner claims fees
for all the transactions included into the block. A transaction fee is set by a
user during transaction creation. Transaction fees are useful for an existing
cryptocurrency economy for two reasons:

\begin{enumerate}
  \item{\em Incentivization of miners.} A rational Bitcoin miner does not
      include all the valid transactions into blocks as, due to the increased
      chances of orphaning a block, the cost of adding transactions to a block
      could not be ignored~\cite{andersen2013,rizun2015transaction}. As shown
      in~\cite{rizun2015transaction}, even in absence of block size limit,
      Bitcoin fee market is healthy and the miners surplus is maximized at a
      finite quantity of block space. Thus the miner is incentivized to produce
      a block of a limited size. This means that only a subset of transactions
      which provides enough value to a miner will be included in a block. A
      paper~\cite{rizun2015transaction} provides a procedure to calculate
      transaction fee based on block propagation time.

  \item{\em Limit resources usage and prevent spam. } Besides of network
      utilization, transaction processing requires a miner to spend some
      computational resources. For most of the cryptocurrencies, a transactional
      language is limited~(with Bitcoin Script~\cite{script} being one of the
      most limited), thus a number of CPU cycles needed to process a transaction
      is strictly bounded and corresponding computational costs are not directly
      considered. In contrast, in cryptocurrencies supporting smart contract
      languages, such as~\cite{seijas2016scripting,tezosScript,solidity},
      transaction processing may require a lot of computations, and
      computational costs are included in transaction fee. This cost is specific
      to concrete transactional language and is out of scope of this paper.
\end{enumerate}

A transaction in Bitcoin fully spends outputs from previous transactions, and
also creates new outputs of user-defined values. A notable and the only
exception is a coinbase transaction of a block which creates fixed amount of
money out of thin air and also claims transaction fees without referring to any
outputs~(a fee for a non-coinbase transaction is sum of claimed outputs values
minus sum of values for created outputs). A node is checking a transaction in
Bitcoin by using a set of unspent outputs. In other cryptocurrencies a
representation of a {\em state} needed to validate and process an arbitrary
transaction could be different~(for example, in Ethereum~\cite{ethyp} such
structure is called the {\em world state} and fixed by the protocol). To process
a transaction quickly, the state~(or most accessed part of it) should reside in
random-access memory. Once it becomes too big to fit into RAM an attacker can
perform denial-of-service attacks against cryptocurrency nodes. For example,
during attacks on Ethereum in Autumn, 2016, an attacker added about 18 million
accounts to the state~(whose size was less than 1 million accounts before the
attack) and then performed succesful denial-of-service attacks against the
nodes\cite{eth2016dos}. Similarly, in 2013 a denial-of-service attack against
serialized transactions residing in a secondary storage~(HDD or SSD) was
discovered in Bitcoin\cite{vasek2014empirical}.

In all the cryptocurrencies of today we are aware of, an element of the state once created 
lives possibly forever without paying anything for that. This leads to continuously increasing state~(we point
to Bitcoin unspent transaction outputs~(UTXO) set size as an
example~\cite{utxoChart}). Moreover, state may grow fast during spam attacks, for
example, 15 million outputs were quickly put into UTXO set during spam attacks
against Bitcoin in July 2015~\cite{bitcoin2015flood}, and most of these outputs
are not spent yet. The paper~\cite{reyzin2016improving} is proposing a technical
solution for non-mining nodes where only miners hold the full state~(assuming
that they can invest money in  random-access memory of sufficiently big
capacity), while other nodes are checking proofs of state transformations
generated by miners, and size of a proof (in average and also in a worst case)
is about $log(S)$ in regards with a state size $S$. Nevertheless, big state
could lead to centralization of mining or SPV mining~\cite{spvMining}, and these
concerns should be addressed. Also, there is an increasing demand to use a
blockchain as a data storage, and storing permanently objects in the state
without a cleaning procedure is not a viable option.

\subsection{Our contributions}

In this paper we propose an economic solution to the problem of unreasonable state growth
(such as spam attacks, or objects not being using anymore but still living in
the blockchain). The solution is a new mandatory fee component. We state that a
user should pay a fee based on both the additional space needed to store objects
created by a transaction, and also for lifetime of the new bytes. This model is
usual for cloud storage services where users pay for gigabytes of data per
month. 

In the paper we also consider an approach to combine fees charged for different resources consumed by a transaction:
bandwidth, random-access memory to hold state, and processor cycles to process computations prescribed by the transaction.    
We propose to charge only for a resource which consumed at most, so we can say about state-oriented, network-oriented or computation-oriented transactions. We provide an evaluation of Ethereum usage data which shows that it is possible for this cryptocurrency to determine transaction type.

We propose a convenient way to charge for state memory consumption~(considering output lifetime also). Our approach is convenient for users who often do not know for how long they would like to store their outputs in the system. The approach is called scheduled payments, as we propose to charge periodically for the bytes of memory consumed.



%We provide a possibility for miners to control their storage requirements by changing a fee factor. 
%Later in this paper we will refer to this new fee component as to a {\em space-time fee}.

%Proposed fee regime is promoting money circulation in the blockchain economy.
%The limited lifetime of a state element also leads to lost coins being taken
%back into circulation~(supposedly by miners). 

%Summarizing, we study an economy where quick-access storage of a node in a
%massively-replicated system becomes the most scarce system resource eventually.
%Thus we call such an economy a {\em space-scarce economy}.

\subsection{Structure of the paper}
The paper is organized as follows. We put assumptions behind our model and its analysis into Section~\ref{sec:preliminaries}. Then we provide an algorithm for a composite fee assignment in Section~\ref{sec:algorithm}. We propose a possible approach to charge for state memory consumption in Section~\ref{sec:scheduled}. We show results of Ethereum data evaluation in Section~\ref{sec:evaluation}. We conclude with Section~\ref{sec:conslusion}.

%A design of our new fee component is
%provided in Section~\ref{sec:model}. The model then is analyzed in
%Section~\ref{sec:analysis}. In Section~\ref{sec:rel-work} we observe related
%work, and in Section~\ref{sec:further-work} we shape a plan for further
%research.

\section{Preliminaries}
\label{sec:preliminaries}

We shape our model with the following assumptions:
\begin{enumerate}[label=\textbf{A\arabic*. }]
  % \item All the fees for a block are going to just a miner like in Bitcoin.
  %    There are proposals to share the rewards for a block within a group of
  %    miners, for example in~\cite{eyal2016bitcoin,kogias2016enhancing}, and
  %    they are out of scope of the paper. A notable difference is that if a single miner
  %    is taking all the rewards, he can include his own transactions in it for free
  \item Without loss of generality, we assume throughout the paper that a transaction creates new objects called outputs and spends outputs from previous transactions. Thus the state needed for transaction validation is about a set of outputs yet unspent. The size of the state then is the sum of sizes of all unspent outputs.  
  \item We assume that a transaction does not change size of the state significantly
  \item For an implementation, we assume that validation state in in the form of unspent transaction outputs set, like in Bitcoin
  \item For an implementation, we assume that it is profitable for a miner to collect fees from unspent outputs. 
  %\item For simplicity, we assume that a block is of a finite size but all the
  %    transactions a miner has at a moment of block generation can be packed
  %    into it, if otherwise is not stated explicitly
  \item We are considering minimal mandatory fees in the paper. All the nodes
      are checking that a fee paid by a transaction is not less than a minimum
      and rejecting the whole block if it contains a transaction violating fee
      rules. Thus a fee regime is considered as a part of consensus protocol in
      our work. A user can pay more than the minimum to have a higher priority
      for a transaction of interest
\end{enumerate}


\section{An algorithm for the fee assignment}
\label{sec:algorithm}

As mentioned in the introduction, we develop rules a fee regime having two goals
in mind, namely incentivization of miners and spam prevention.  In this chapter
we reason about the guiding  principles for the fee assignment, and end up with
the example of a practical fee assignment rule.

The evolution of the blockchain networks has demonstrated the main resources
being used. First and the most important so far, the memory of the network nodes 
is limited resource. Blocks in the blockchain after processing are storing on a 
secondary storage, where a cost of a storage unit is low. In contrast, to validate a 
transaction, some state is needed~(for example, unspent outputs set in Bitcoin is used 
to validate a transaction), and this state should reside in expensive random-access memory.   
An elegant solution has already been found recently~\cite{reyzin2016improving}, making state size growth irrelevant for 
a non-mining full-node, a mining node still needs to store the state in full though.

Second, it becomes obvious, especially with the development of smart contracts,
that a transactional ``cost'' for the node can be more than just a storage:
transactions can contain relatively complicated scripts which are meant to be
executed by all the nodes in the network. The extreme and most famous example is
the Ethereum network implementing the concept of the ``World Computer''~\cite{ethyp}. 

Third, there is the network load created by every transaction. If an output is
created in one block and spent right in the next one, it provides almost zero
overhead in terms of validation state size, but creates the network load needed
for synchronization.

A transaction fee should incorporate all the three components stated above. We
propose to charge for a component which demands more resources. That is,
state-oriented transactions should be charged for state memory consumption, the
computation-oriented transactions should be charged for script execution, and
all the others by the network load. This can be formalized as follows:
\begin{equation}
    \operatorname{Fee}(tx) = \max\left(\alpha \cdot N_b(tx), \beta \cdot N_c(tx),
    S(state) \cdot \sum_i (B_i \cdot sT_i) \right)\,.
    \label{eq:max}
\end{equation}
Here $\alpha$ and $\beta$ are the pricing coefficients, $N_b(tx)$ is the number
of bytes in the transaction, which defines the network load, $N_c(tx)$ is the
estimate of the computational cost of transaction, $S(state)$ is the cost of the
storage of byte of output in the state for the unit of time, $sT_i$ is the time
for which the output $i$ is being stored in the state, and $B_i$ is its size in
bytes.

Since the time for the data to reside in the state is usually unknown,
the right hand side of Eq.~\eqref{eq:max} cannot be deduced directly at
transaction submission time. For this purpose we introduce a proposal for 
scheduled payments later in Section~\ref{sec:scheduled}. The latter
argument in Eq.~\eqref{eq:max} becomes dominant with time. Starting at the moment when it happens, the
fee is increasing at a constant rate (see Fig.~\ref{fig:max_t}). The possible implementation of this 
algorithm is described in Section~\ref{sec:scheduled}.
\begin{figure}
    \centering
    \begin{subfigure}[b]{.45\textwidth}
    \includestandalone[width=\textwidth]{figures/subsid}
    \caption{Transaction cost as a function of the output existence time.
        \newline
        \label{fig:max_t}}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{.45\textwidth}
        \includestandalone[width=\textwidth]{figures/max_est}
        \caption{Space of transactions split by
            Eq.~\eqref{eq:max} into the subregions of the dominant fees.
            \label{fig:max}}
        \end{subfigure}
        \caption{Fee differentiation by resource consumption}
\end{figure}

The obvious questions here are as follows. What are the guiding principles for
choosing $\alpha$, $\beta$ and $S(\cdot)$? There is also the
question of estimating $N_c(tx)$, which can be solved only by executing the
script for Turing--complete languages. It is known as the worst case execution
time problem~\cite{Wilhelm2008}.  We leave the latter question beyond the scope of
the paper, and answer the former one below.

\subsection{Choice of the relative values of $\alpha$, $\beta$, $S(state)$}

Assume for now, that for every transaction we know for how long the outputs will be
stored in the state. We will overcome this difficulty later. Based on
Eq.~\eqref{eq:max}, we come up with the notion of space of transactions, which
is three--dimensional in our case --- every transaction is defined by three
numbers: $N_b(tx)$, $N_c(tx)$, $N_s(state,tx) = \sum_i (B_i \cdot sT_i)$. Eq.~\eqref{eq:max} is splitting 
this space into three regions: network--oriented transactions, space--oriented transactions, 
and computation--oriented transactions (see Fig.~\ref{fig:max}). All the splitting 
is governed by the direction of vector $\vec{n}$ which defines the line $\alpha N_b=\beta N_c=N_s$.
Varying the coefficients $\alpha$ and $\beta$, one can change the direction of
$\vec{n}$ adjusting the formal fee prescription to the sensible values.

\subsection{Choice of $S(state)$}

The simplest way of assigning the $S(state)$ value is by making it constant.
%That is, specifying the price of storage of 1 byte of data per one day. 
However, as it is shown in the Appendix~\ref{apx:statesize}, this does not fully solve
the problem of limiting the state size. What is being controlled in this case,
that is the rate at which the data is being submitted, but not the state size
itself. One could also manually define the maximal size of the state for the
network. This solution, in turn, has its own caveats. For example, once the
state is kept (almost) full by the participants, it can be (almost) impossible
to submit the transaction increasing the state size.  The time till it becomes
possible is hardly predictable. 

Preferable properties of the current state size could be formulated as follows:
it should be predictable, stable, and below some externally given value (an upper
bound on state size, being unique for the whole network). 

Another natural question arising is whether the rigid state size restriction is
necessary?  It is easy to imagine the situation where the formal possibility of
exceeding the state is still present, but hardly ever being used. For example,
if one wants to constrain the state size to 10MB, the possible solution is to
set normal price for submitting data to store if the state size after submission
is below 10MB, but some astronomical price for the luxury of storage above 10MB.
So, formally it will be possible, but in fact, hardly ever used, with every
usage bringing significant profit to miners. The generalization of this idea is
to form the explicit dependence of price on the state load (it will referred to
as ``pricing curve''). The good pricing curve must provide at least one stable
equilibrium of the state size; the minimal dependence on initial conditions (if
possible), and high rewards for miners. The latter could serve as good
optimization parameter. Extreme cases are zero price -- huge data submission --
miners get nothing; and infinite price -- zero data submission -- miners get
nothing. As usual, a maximal outcome is in between.  The pricing policies
described above are two particular cases of pricing curve (see
Fig.~\ref{fig:steps}). That is, we assume that the price of data storage in the
state $S(state)$ varies with the current state load $x$. 
\begin{figure} 
    \hfill 
    \begin{tikzpicture} 
        \draw[thick,-stealth] (0,0) -- (0,3) node [right]{$S(state)$}; 
        \draw[thick,-stealth] (0,0) -- (5,0) node [above]{load}; 
        \draw[very thick] (0,0.3) -- (3,0.3) -- (3,3); 
        \draw[dotted] (3,1) -- (3,0) node[below]{$10$MB}; 
    \end{tikzpicture} 
    \hfill 
    \begin{tikzpicture} 
        \draw[thick,-stealth] (0,0) -- (0,3) node [right]{$S(state)$}; 
        \draw[thick,-stealth] (0,0) -- (5,0) node [above]{load}; 
        \draw[very thick] (0,0.3) -- (3,0.3) -- (3,2) -- (5,2); 
        \draw[dotted] (3,1) -- (3,0) node[below]{$10$MB}; 
    \end{tikzpicture} 
    \hfill 
    \caption{ 
        Examples of pricing curves: rigid state size restriction (left) and 
        overflow fees (right, see text). The value of $10$MB is taken 
        arbitrarily. 
        \label{fig:steps} 
    } 
\end{figure} 

Note that the pricing curve is defined by a small number of parameters and
to be the same for all the network. To impose an upper bound on the state
size, one can choose the pricing curve formally going to infinity at some finite
state size. The rigid boundary can be provided by divergence higher than
$1/(x_{max}-x)$. One can also try to estimate the optimal state size for a given
differentiable pricing curve. In the continual with the assumptions
described in the appendix, the data submission rate $N(S(x))$ is fully defined by the
current storage price $S(x)$.  Rewards rate obtained by the miners for stable
state size at price $S$ is given by $y = S \cdot N(S)$. An example is provided at
Fig.~\ref{fig:rewards}. First, it provides a possible method of measuring
explicit form of the function $N(S)$ in the model: one has to set up the price,
and observe the static rewards. Second, one may wonder about the price $S^*$,
optimal for the miners in terms of rewards. Obviously, it satisfies
$N(S^*)+S^*N'(S^*)=0$, where prime is derivative with respect to price. As
usual, the optimal price here does not depend on the pricing policy, but rather
the implicit property of the network. \knote{what does the last sentence mean?}  Having the price varying freely can be
considered beneficial both for miners and for network as a whole, since it
allows the first ones to optimize signing strategy, and with this given the
state size is automatically adjusted to the relatively predictable level
$S^{-1}(S^*)$.

\begin{figure}
    \includestandalone[width=\textwidth]{figures/rewards}
    \caption{
        \label{fig:rewards} Example of the rewards curve.
    }
\end{figure}

\section{Scheduled Payments}
\label{sec:scheduled}

In this section we propose a concrete way to charge for state bytes consumed~(or released). There are few possible options for that. A user, for example, may specify lifetime for a coin during its creation and pay for it in advance, this is not very convenient for him though. Another option is to charge when coin is spent, or allow to spend a coin~(by anyone, presumably, a miner) when its value is overweighted by state fee. As a drawback, if coin is associated with a big value, it could live for very long, maybe without a reason. 

We propose more convenient method of charging; we name it {\em scheduled payments}. In this scheme a user must set special predefined script for a coin~(otherwise a transaction and also a block containing it are invalid), which contains a user-specific logic~(we call it {\em regular script}) and a spending condition which allows anyone~(presumably, a miner) to create a transaction claiming this output, necessarily creating a the coin with the same guarding condition and a value not less than original minus a state fee. These two parts~(regular script and a fee charging condition) are connected by using the $\lor$ conjecture. We assume that $\alpha$ and $\beta$ are fixed. We also assume that subsidized period $sT$ is to be stored along with the coin by each validating node. Then a guarding script for the coin would be like:

\begin{align}
\begin{split}
&(regular\_script) \lor \\
&(height > (out.height + sT) \land (out.value \le S(state) \cdot B \cdot sT \lor \\  
&\qquad tx.has\_output(value = out.value - S(state) \cdot B \cdot sT, script = out.script)))
\end{split}
\end{align}

, where $height$ is a height of a block which contains a spending transaction, $out.height$ is a height when the output was created, $out.height$ and $out.script$ contain the output's value and spending script respectively, predicate $tx.has\_output()$ checks whether a spending transaction has an output with conditions given as the predicate arguments. As in Section~\ref{sec:algorithm}, $B$ is the output size.     


\section{Evaluation}
\label{sec:evaluation}

The question we address in this section is ``What should be the real-world
ratio between the pricing coefficients?'' To extract the realistic possible
values, and verify the validity of described transaction classification, the
data from the Ethereum network was taken. We consider Ethereum a good example,
since all three components of the resource consumption are present in its
network. The network load parameter $N_b(tx)$ is a transaction size; the state
load $\Delta(tx)$ can also be deduced from the blockchain by processing SSTORE
and CREATE operations in transactions. To quantify the
computational load $N_c(tx)$, the built-in Ethereum gas system was used. As the
gas usage of the Ethereum transaction contains the base cost proportional to the
transaction size and the storage cost, proportional to number of SSTORE and CREATE
operations, the corresponding gas has been subtracted from computational load.

\begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{figures/txs3d}
        \caption{}
        \label{fig:a}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{figures/txs-size-computation}
        \caption{}
        \label{fig:b}
    \end{subfigure}

    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{figures/txs-size-storage}
        \caption{}
        \label{fig:a}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{figures/txs-storage-computation}
        \caption{}
        \label{fig:b}
    \end{subfigure}

    \caption{Ethereum transactions differentiation by resource consumption}\label{fig:animals}
\end{figure}

\dnote{make letters larger}

The results of processing first $2\cdot10^6$ blocks in Ethereum network are presented on Fig.4. Each point corresponds to the
transaction.  One can notice that parts of the distribution on Fig.4 extend
along the coordinate axis --- these are the transactions which can be
unambiguously distinguished by their type of the resource consumption. Their
presence confirms our expectations on the nature of resource consumption, and
serves as a justification of the proposed classification scheme. The space of
transactions is split into three parts by the aforementioned vector $\mathbf{n}$ \dnote{where was in mentioned?}
with the endpoint at the first momentum of the distribution.

Another parameter of interest is the storage time. Using it directly
from the blockchain in weakly relevant to our scheme because the participants do
not get any reward for removing it from the state earlier rather than later.
However, we consider the time delay between the data submission and its
addressing to be the reliable parameter reflecting the needs of the users.
Analysis of Ethereum blockchain showed that in a lot of cases data stored in the state
was touched by other transactions in the same block or few blocks after insertion.
We assumed that in this was not interesting to us blockchain as storage use case
and this data is not representative. Excluded such short-lived data from our analysis
we estimated that average lifetime of a data in Ethereum is 23731 blocks or about 4 days
regarding 15 seconds average time internal between blocks.

This gives the following estimate on the ratio between the pricing coefficients for the expected state size:

\begin{align}
\begin{split}
&\frac{\alpha}{\beta} \approx 7.7\cdot10^{-3} \\
&\frac{\alpha}{S} \approx 6.7\cdot10^{-4}
\end{split}
\end{align}

where $S$ is the cost of the storage of byte of output in the state for one block and does
not depend on state size in Ethereum. This estimations are quite approximate, while their
changes won't affect fees for most of transactions, that can unambiguously be attributed
to concrete type of the resource consumption.

\section{Conclusion}
\label{sec:conslusion}

\bibliographystyle{splncs03}
\bibliography{sources.bib}

\appendix

\section{State size dynamics}
\label{apx:statesize}
For the primary analysis we assume that participants act honestly: they submit
data if they need to do so and it is affordable; they do not in the opposite
case. For the sake of simplicity, suppose that the time of storage of data
block is fixed, and equal to $T$. In order to reduce the discrete stochastic
model to continuous deterministic one, assume that the number of participants
is large, and the typical size of the submitted data chunk is much less than
characteristic pricing curve variation scale. The amount of data submitted to
the state is changing continuously. At every given moment of time the users
submit the data at some rate (say, MB/s) $f$, which is defined by the current
price (participants submit more when cheap, and less when expensive). The
current price is fully determined by the current state load $x$. After time
interval $T$ data is erased from the state. The data is written into the state
at rate $f(x(t))$, and erased at rate $f(x(t-T))$. Under these assumptions,
the evolution of the state load is defined by the following equation:
\begin{equation}
    \frac{dx}{dt} = f(x(t))-f(x(t-T))\,.
    \label{eq:dde0}
\end{equation}
If one measures time in the data block TTL $T$, the equation takes the form
\begin{equation}
    \dot{x} = f(x(t))-f(x(t-1))\,.
    \label{eq:dde1}
\end{equation}
The equations of this type are called delay differential equations (DDE), and have
been studied widely for the vast amount of control problems.

Now few words about the function $f$, and how to convert it to the miner's
income. What participants know is the pricing curve $S(x)$. For every value $P$
of this function there is amount of people $N(S)$ who want to submit data and
can afford it at time interval $T$. The function $N(S)$ is non-increasing, and
going to zero for sufficiently large $S$ (every participant has maximal price he
is ready to pay, and will also try to submit something if current price is
lower; for sufficiently large price no one is ready to pay). In these notations
$f(x)=N(S(x))$ (see inset on Fig.~\ref{fig:rewards}), and the profit rate which
miners get from current submissions is $y(t) = S(x(t))f(x(t))$.

\subsection{Constant storage price}
\subsection{State-dependent storage price}
\begin{figure}
    \includestandalone[width=\textwidth]{figures/dynamics}
    \caption{
        \label{fig:dynamics} Dynamics of the state size for various initial
        rates. The numbers above the curves are the miners reward rates with
        respect to maximal possible stationary rewards.
    }
\end{figure}

\end{document}
