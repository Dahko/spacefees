\documentclass[]{llncs}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
\graphicspath{{./figures/}}
\usepackage{subcaption}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{standalone}
\usepackage{pgfplots}
%% The amsthm package provides extended theorem environments
%\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}

\usepackage{listings}

\usepackage{hyperref}

\usepackage{systeme}

\usepackage{enumitem}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1\textcolor{blue}{ #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes:}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{red}{Dima notes:}}{#1}}}
\newcommand{\vk}[1]{{\authnote{\textcolor{red}{V:}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\pgfplotsset{compat=newest, table/search path=figures}

\begin{document}

\title{A Systematic Approach To Cryptocurrency Fees}

%\title{On Space-Scarce Economy\\ In Blockchain Systems}

%\author{Alexander Chepurnoy \and Vasily Kharin \and Dmitry Meshkov}
%\institute{IOHK Research}
\maketitle

\begin{abstract}

In this paper we study space-scarce economy in massively replicated open
blockchain systems. In these systems, such as Bitcoin, memory to hold a current
state snapshot needed to validate transactions becomes the most scarce resource
eventually. The issue is even more critical for blockchain systems used to store
data~(votes, certificates, logs etc.). Uncontrolled state size growth could lead
to security issues, such as denial-of-service attacks. Only technical solutions,
not economic, have been proposed to tackle this problem to the moment. In
contrast, we propose to add a new component to a transaction fee scheme based on
how much additional space will be needed for new objects created in result of
transaction processing and for how long they will live in the state. \knote{write abt fee adjustment rule} 
%We provide three possible options towards implementing the new fee component, namely
%\textit{prepaid outputs}, \textit{postpaid outputs} and \textit{scheduled
%payments}. We provide an analysis of the model with respect to all the three
%options.
\knote{rewrite further} 
 We show that the state growth could be bounded by a fee factor, miners
are getting additional stable rewards and lost coins are being taken back into
circulation eventually.    \knote{check this}

\end{abstract}

\section{Introduction}

Bitcoin~\cite{Nakamoto2008} was introduced in 2008 by S. Nakamoto as a purely
peer-to-peer version of electronic cash with a ledger written into blockchain
data structure securely replicated by each network node. Security of the scheme
is relied on mining process. If majority of miners are honest, then Bitcoin
meets its security goals as formal analysis~\cite{Garay2015} shows. For work
done a miner is claiming a reward which consists of two parts. First, some
constant number of bitcoins are created out of thin air according to a
predefined and hard-coded token emission schedule. Second, a miner claims fees
for all the transactions included into the block. A transaction fee is set by a
user during transaction creation. Transaction fees are useful for an existing
cryptocurrency economy for two reasons:

\begin{enumerate}
  \item{\em Incentivization of miners.} A rational Bitcoin miner does not
      include all the valid transactions into blocks as, due to the increased
      chances of orphaning a block, the cost of adding transactions to a block
      could not be ignored~\cite{andersen2013,rizun2015transaction}. As shown
      in~\cite{rizun2015transaction}, even in absence of block size limit,
      Bitcoin fee market is healthy and the miners surplus is maximized at a
      finite quantity of block space. Thus the miner is incentivized to produce
      a block of a limited size. This means that only a subset of transactions
      which provides enough value to a miner will be included in a block. A
      paper~\cite{rizun2015transaction} provides a procedure to calculate
      transaction fee based on block propagation time.

  \item{\em Limit resources usage and prevent spam. } Besides of network
      utilization, transaction processing requires a miner to spend some
      computational resources. For most of the cryptocurrencies, a transactional
      language is limited~(with Bitcoin Script~\cite{script} being one of the
      most limited), thus a number of CPU cycles needed to process a transaction
      is strictly bounded and corresponding computational costs are not directly
      considered. In contrast, in cryptocurrencies supporting smart contract
      languages, such as~\cite{seijas2016scripting,tezosScript,solidity},
      transaction processing may require a lot of computations, and
      computational costs are included in transaction fee. This cost is specific
      to concrete transactional language and is out of scope of this paper.
\end{enumerate}

A transaction in Bitcoin fully spends outputs from previous transactions, and
also creates new outputs of user-defined values. A notable and the only
exception is a coinbase transaction of a block which creates fixed amount of
money out of thin air and also claims transaction fees without referring to any
outputs~(a fee for a non-coinbase transaction is sum of claimed outputs values
minus sum of values for created outputs). A node is checking a transaction in
Bitcoin by using a set of unspent outputs. In other cryptocurrencies a
representation of a {\em state} needed to validate and process an arbitrary
transaction could be different~(for example, in Ethereum~\cite{ethyp} such
structure is called the {\em world state} and fixed by the protocol). To process
a transaction quickly, the state~(or most accessed part of it) should reside in
random-access memory. Once it becomes too big to fit into RAM an attacker can
perform denial-of-service attacks against cryptocurrency nodes. For example,
during attacks on Ethereum in Autumn, 2016, an attacker added about 18 million
accounts to the state~(whose size was less than 1 million accounts before the
attack) and then performed succesful denial-of-service attacks against the
nodes\cite{eth2016dos}. Similarly, in 2013 a denial-of-service attack against
serialized transactions residing in a secondary storage~(HDD or SSD) was
discovered in Bitcoin\cite{vasek2014empirical}.

The main purpose of this paper is to consider a new mandatory component in a
transaction fee scheme reflecting state growth. In all known cryptocurrencies of
today, an element of the state once created lives possibly forever without
paying anything for that. This leads to continuously increasing state~(we point
to Bitcoin unspent transaction outputs~(UTXO) set size as an
example~\cite{utxoChart}). Moreover, state may grow fast during spam attack, for
example, 15 million outputs were quickly put into UTXO set during spam attacks
against Bitcoin in July 2015~\cite{bitcoin2015flood}, and most of these outputs
are not spent yet. The paper~\cite{reyzin2016improving} is proposing a technical
solution for non-mining nodes where only miners hold the full state~(assuming
that they can invest money in  random-access memory of sufficiently big
capacity), while other nodes are checking proofs of state transformations
generated by miners, and size of a proof (in average and also in a worst case)
is about $log(S)$ in regards with a state size $S$. Nevertheless, big state
could lead to centralization of mining or SPV mining~\cite{spvMining}, and these
concerns should be addressed. Also, there is an increasing demand to use a
blockchain as a data storage, and storing permanently objects in the state
without a cleaning procedure is not a viable option.

\subsection{Our contributions}

We propose an economic solution to the problem of unreasonable state growth
(such as spam attacks, or objects not being using anymore but still living in
the blockchain). The solution is a new mandatory fee component. We state that a
user should pay fee for both the additional space needed to store objects
created by a transaction, and also for lifetime of new bytes. This model is
usual for cloud storage services where users pay for gigabytes of data per
month. We provide a possibility for miners to control their storage requirements
by changing a fee factor. Later in this paper we will refer to this new fee
component as to a {\em space-time fee}.

\knote{write abt fee adjustment rule}

Proposed fee regime is promoting money circulation in the blockchain economy.
The limited lifetime of a state element also leads to lost coins being taken
back into circulation~(supposedly by miners). 

Summarizing, we study an economy where quick-access storage of a node in a
massively-replicated system becomes the most scarce system resource eventually.
Thus we call such an economy a {\em space-scarce economy}.

\subsection{Structure of the paper}
The paper is organized as follows. We put assumptions behind our model and its analysis into Section~\ref{sec:preliminaries}. Then we provide an algorithm for the fee assignment in Section~\ref{sec:algorithm}. \knote{todo: finish}

%A design of our new fee component is
%provided in Section~\ref{sec:model}. The model then is analyzed in
%Section~\ref{sec:analysis}. In Section~\ref{sec:rel-work} we observe related
%work, and in Section~\ref{sec:further-work} we shape a plan for further
%research.

\section{Preliminaries}
\label{sec:preliminaries}

We shape our model with the following assumptions:
\begin{enumerate}[label=\textbf{A\arabic*. }]
  % \item All the fees for a block are going to just a miner like in Bitcoin.
  %    There are proposals to share the rewards for a block within a group of
  %    miners, for example in~\cite{eyal2016bitcoin,kogias2016enhancing}, and
  %    they are out of scope of the paper. A notable difference is that if a single miner
  %    is taking all the rewards, he can include his own transactions in it for free
  \item We assume that a transaction does not change size of a validation state significantly
  \item For an implementation, we assume that validation state in in the form of unspent transaction outputs set, like in Bitcoin
  \item For an implementation, we assume that it is profitable for a miner to collect fees from unspent outputs. 
  %\item For simplicity, we assume that a block is of a finite size but all the
  %    transactions a miner has at a moment of block generation can be packed
  %    into it, if otherwise is not stated explicitly
  \item We are considering minimal mandatory fees in the paper. All the nodes
      are checking that a fee paid by a transaction is not less than a minimum
      and rejecting the whole block if it contains a transaction violating fee
      rules. Thus a fee regime is considered as a part of consensus protocol in
      our work. A user can pay more than the minimum to have a higher priority
      for a transaction of interest
\end{enumerate}


\section{An algorithm for the fee assignment}
\label{sec:algorithm}

As mentioned in the introduction, we develop rules a fee regime having two goals
in mind, namely incentivization of miners and spam prevention.  In this chapter
we reason about the guiding  principles for the fee assignment, and end up with
the example of a practical fee assignment rule.

The evolution of the blockchain networks has demonstrated the main resources
being used. First and the most important so far, the memory of the network nodes 
is limited resource. Blocks in the blockchain after processing are storing on a 
secondary storage, where a cost of a storage unit is low. In contrast, to validate a 
transaction, some state is needed~(for example, unspent outputs set in Bitcoin is used 
to validate a transaction), and this state should reside in expensive random-access memory.   
An elegant solution has already been found recently~\cite{reyzin2016improving}, making state size growth irrelevant for 
a non-mining full-node, a mining node still needs to store the state in full though.

Second, it becomes obvious, especially with the development of smart contracts,
that a transactional ``cost'' for the node can be more than just a storage:
transactions can contain relatively complicated scripts which are meant to be
executed by all the nodes in the network. The extreme and most famous example is
the Ethereum network implementing the concept of the ``World Computer''~\cite{ethyp}. 

Third, there is the network load created by every transaction. If an output is
created in one block and spent right in the next one, it provides almost zero
overhead in terms of validation state size, but creates the network load needed
for synchronization.

A transaction fee should incorporate all the three components stated above. We
propose to charge for a component which demands more resources. That is,
storage-oriented transactions should be charged for storage consumption, the
computation-oriented transactions should be charged for script execution, and
all the others by the network load. This can be formalized as follows:
\begin{equation}
    \operatorname{Fee}(tx) = \max\left(\alpha \cdot N_b(tx), \beta \cdot N_c(tx),
    S(state) \cdot \sum_i (B_i \cdot sT_i) \right)\,.
    \label{eq:max}
\end{equation}
Here $\alpha$ and $\beta$ are the pricing coefficients, $N_b(tx)$ is the number
of bytes in the transaction, which defines the network load, $N_c(tx)$ is the
estimate of the computational cost of transaction, $S(state)$ is the cost of the
storage of byte of output in the state for the unit of time, $sT_i$ is the time
for which the output $i$ is being stored in the state, and $B_i$ is its size in
bytes.

Since the time for the data to reside in the state is usually unknown,
the right hand side of Eq.~\eqref{eq:max} cannot be deduced directly at
transaction submission time. For this purpose we introduce a proposal for 
scheduled payments later in Section~\ref{sec:scheduled}. The latter
argument in Eq.~\eqref{eq:max} becomes dominant with time. Starting at the moment when it happens, the
fee is increasing at a constant rate (see Fig.~\ref{fig:max_t}). The possible implementation of this 
algorithm is described in Section~\ref{sec:scheduled}.
\begin{figure}
    \centering
    \begin{subfigure}[b]{.45\textwidth}
    \includestandalone[width=\textwidth]{figures/subsid}
    \caption{Transaction cost as a function of the output existence time.
        \newline
        \label{fig:max_t}}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{.45\textwidth}
        \includestandalone[width=\textwidth]{figures/max_est}
        \caption{Space of transactions split by
            Eq.~\eqref{eq:max} into the subregions of the dominant fees.
            \label{fig:max}}
        \end{subfigure}
        \caption{Fee differentiation by resource consumption}
\end{figure}

The obvious questions here are as follows. What are the guiding principles for
choosing $\alpha$, $\beta$ and $S(\cdot)$? There is also the
question of estimating $N_c(tx)$, which can be solved only by executing the
script for Turing--complete languages. It is known as the worst case execution
time problem~\cite{Wilhelm2008}.  We leave the latter question beyond the scope of
the paper, and answer the former one below.

\subsection{Choice of the relative values of $\alpha$, $\beta$, $S(state)$}

Assume for now, that for every transaction we know the time the outputs will be
stored in the state $T[tx]$. We will overcome this difficulty later. Based on
Eq.~\eqref{eq:max}, we come up with the notion of space of transactions, which
is three--dimensional in our case --- every transaction is defined by three
numbers: $N_b(tx)$, $N_c(tx)$, $N_s(state,tx) = S(state)T[tx]$. Eq.~\eqref{eq:max} provides a
prescription of splitting this space into three regions: network--oriented
transactions, space--oriented transactions, and computation--oriented
transactions (see Fig.~\ref{fig:max}). All the splitting is governed by the
direction of vector $\vec{n}$ which defines the line $\alpha N_b=\beta N_c=N_s$.
Varying the coefficients $\alpha$ and $\beta$, one can change the direction of
$\vec{n}$ adjusting the formal fee prescription to the sensible values.

\subsection{Choice of $S(state)$}

The simplest way of assigning the value of $S(state)$ is by making it constant.
That is, specifying the price of storage of 1 byte of data per one day. However,
as it is shown in the Appendix~\ref{apx:statesize}, this does not fully solve
the problem of limiting the state size. What is being controlled in this case,
that is the rate at which the data is being submitted, but not the state size
itself. One could also manually define the maximal size of the state for the
network. This solution, in turn, has its own caveats. For example, once the
state is kept (almost) full by the participants, it can be (almost) impossible
to submit the transaction increasing the state size.  The time till it becomes
possible is hardly predictable. 

Preferable properties of the current state size could be formulated as follows:
it should be predictable, stable, and below some externally given value (upper
restriction on state size, being unique for the whole network). 

Another natural question arising is whether the rigid state size restriction is
necessary?  It is easy to imagine the situation where the formal possibility of
exceeding the state is still present, but hardly ever being used. For example,
if one wants to constrain the state size to 10MB, the possible solution is to
set normal price for submitting data to store if the state size after submission
is below 10MB, but some astronomical price for the luxury of storage above 10MB.
So, formally it will be possible, but in fact, hardly ever used, with every
usage bringing significant profit to miners. The generalization of this idea is
to form the explicit dependence of price on the state load (it will referred to
as ``pricing curve''). The good pricing curve must provide at least one stable
equilibrium of the state size; the minimal dependence on initial conditions (if
possible), and high rewards for miners. The latter could serve as good
optimization parameter. Extreme cases are zero price -- huge data submission --
miners get nothing; and infinite price -- zero data submission -- miners get
nothing. As usual, a maximal outcome is in between.  The pricing policies
described above are two particular cases of pricing curve (see
Fig.~\ref{fig:steps}). That is, we assume that the price of data storage in the
state $S(state)$ varies with the current state load $x$. 
\begin{figure} 
    \hfill 
    \begin{tikzpicture} 
        \draw[thick,-stealth] (0,0) -- (0,3) node [right]{$S(state)$}; 
        \draw[thick,-stealth] (0,0) -- (5,0) node [above]{load}; 
        \draw[very thick] (0,0.3) -- (3,0.3) -- (3,3); 
        \draw[dotted] (3,1) -- (3,0) node[below]{$10$MB}; 
    \end{tikzpicture} 
    \hfill 
    \begin{tikzpicture} 
        \draw[thick,-stealth] (0,0) -- (0,3) node [right]{$S(state)$}; 
        \draw[thick,-stealth] (0,0) -- (5,0) node [above]{load}; 
        \draw[very thick] (0,0.3) -- (3,0.3) -- (3,2) -- (5,2); 
        \draw[dotted] (3,1) -- (3,0) node[below]{$10$MB}; 
    \end{tikzpicture} 
    \hfill 
    \caption{ 
        Examples of pricing curves: rigid state size restriction (left) and 
        overflow fees (right, see text). The value of $10$MB is taken 
        arbitrarily. 
        \label{fig:steps} 
    } 
\end{figure} 

Note that the pricing curve is defined by a small number of parameters and
to be the same for all the network. To impose the upper restriction on the state
size one can choose the pricing curve formally going to infinity at some finite
state size. The rigid boundary can be provided by divergence higher than
$1/(x_{max}-x)$. One can also try to estimate the optimal state size for a given
differentiable pricing curve. In the continual with the assumptions
described in the appendix, the data submission rate $N(S(x))$ is fully defined by the
current storage price $S(x)$.  Rewards rate obtained by the miners for stable
state size at price $S$ is given by $y = S \cdot N(S)$. An example is provided at
Fig.~\ref{fig:rewards}. First, it provides a possible method of measuring
explicit form of the function $N(S)$ in the model: one has to set up the price,
and observe the static rewards. Second, one may wonder about the price $S^*$,
optimal for the miners in terms of rewards. Obviously, it satisfies
$N(S^*)+S^*N'(S^*)=0$, where prime is derivative with respect to price. As
usual, the optimal price here does not depend on the pricing policy, but rather
the implicit property of the network. \knote{what does the last sentence mean?}  Having the price varying freely can be
considered beneficial both for miners and for network as a whole, since it
allows the first ones to optimize signing strategy, and with this given the
state size is automatically adjusted to the relatively predictable level
$S^{-1}(S^*)$.

\begin{figure}
    \includestandalone[width=\textwidth]{figures/rewards}
    \caption{
        \label{fig:rewards} Example of the rewards curve.
    }
\end{figure}

\section{Scheduled Payments}
\label{sec:scheduled}

In this section we propose a concrete way to charge for state bytes consumed~(or released). There are few possible options for that. A user, for example, may specify lifetime for a coin during its creation and pay for it in advance, this is not very convenient for him though. Another option is to charge when coins are being spent, or allow to spend a coin~(by anyone, presumably, a miner) when its value is overweighted by space-time fee. As a drawback, if coin is associated with a big amount of tokens, it could live for very long, maybe without a reason. 

We propose more convenient method of charging; we name it {\em scheduled payments}. In this scheme a user must set special predefined script for a coin~(otherwise a transaction and also a block containing it are invalid), which contains a user-specific logic~(we call it {\em regular script}) and a spending condition which allows anyone~(presumably, a miner) to create a transaction claiming this output, necessarily creating a the coin with the same guarding condition and a value not less than original minus a space-time fee. These two parts~(regular script and a fee charging condition) are connected by using the $\lor$ conjecture. We assume that $\alpha$ and $\beta$ are fixed. We also assume that subsidized period $sT$ is to be stored along with the coin by each validating node. \knote{notation, link to fig. 4}  Then a guarding script for the coin would be like:

\begin{align}
\begin{split}
&(regular\_script) \lor \\
&(Height > (out.height + sT) \land (out.value \le S(state) \cdot B \cdot sT \lor \\  
&\qquad tx.has\_output(value = out.value - S(state) \cdot B \cdot sT, script = out.script)))
\end{split}
\end{align}

\knote{notation: B, sT}

\section{Evaluation}

The question we address in this section is ``What should be the real--world
ratio between the pricing coefficients?'' To extract the realistic possible
values, and verify the validity of described transaction classification, the
data from the Ethereum network was taken. We consider Ethereum a good example,
since all three components of the resource consumption are present in its
network. The network load parameter $N_b(tx)$ is a transaction size; the state
load $\Delta(tx)$ can also be deduced from the blockchain, and to quantify the
computational load $N_c(tx)$, the built-in Ethereum gas system was used.  As the
base cost of the Ethereum transaction contains the terms proportional to the
transaction size (treating zero and non-zero bytes separately), the
corresponding gas has been subtracted (by our terms it falls into the network
load). Another parameter of interest is the storage time.  Using it directly
from the blockchain in weakly relevant to our scheme because the participants do
not get any reward for removing it from the state earlier rather than later.
However, we consider the time delay between the data submission and its
addressing to be the reliable parameter reflecting the needs of the users.

\vk{block range; justify representativeness}

The results are presented on Fig. .. and .. Each point corresponds to the
transaction.  One can notice that parts of the distribution on Fig.~(3d) extend
along the coordinate axis --- these are the transactions which can be
unambiguously distinguished by their type of the resource consumption. Their
presence confirms our expectations on the nature of resource consumption, and
serves as a justification of the proposed classification scheme. The space of
transactions is split into three parts by the aforementioned vector $\mathbf{n}$
with the endpoint at the first momentum of the distribution. This gives the
following estimate on the ratio between the pricing coefficients for the
expected state size:

\section{Conclusions}

\bibliographystyle{ieeetr}
\bibliography{sources.bib}

\appendix

\section{State size dynamics}
\label{apx:statesize}
For the primary analysis we assume that participants act honestly: they submit
data if they need to do so and it is affordable; they do not in the opposite
case. For the sake of simplicity, suppose that the time of storage of data
block is fixed, and equal to $T$. In order to reduce the discrete stochastic
model to continuous deterministic one, assume that the number of participants
is large, and the typical size of the submitted data chunk is much less than
characteristic pricing curve variation scale. The amount of data submitted to
the state is changing continuously. At every given moment of time the users
submit the data at some rate (say, MB/s) $f$, which is defined by the current
price (participants submit more when cheap, and less when expensive). The
current price is fully determined by the current state load $x$. After time
interval $T$ data is erased from the state. The data is written into the state
at rate $f(x(t))$, and erased at rate $f(x(t-T))$. Under these assumptions,
the evolution of the state load is defined by the following equation:
\begin{equation}
    \frac{dx}{dt} = f(x(t))-f(x(t-T))\,.
    \label{eq:dde0}
\end{equation}
If one measures time in the data block TTL $T$, the equation takes the form
\begin{equation}
    \dot{x} = f(x(t))-f(x(t-1))\,.
    \label{eq:dde1}
\end{equation}
The equations of this type are called delay differential equations (DDE), and have
been studied widely for the vast amount of control problems.

Now few words about the function $f$, and how to convert it to the miner's
income. What participants know is the pricing curve $S(x)$. For every value $P$
of this function there is amount of people $N(S)$ who want to submit data and
can afford it at time interval $T$. The function $N(S)$ is non-increasing, and
going to zero for sufficiently large $S$ (every participant has maximal price he
is ready to pay, and will also try to submit something if current price is
lower; for sufficiently large price no one is ready to pay). In these notations
$f(x)=N(S(x))$ (see inset on Fig.~\ref{fig:rewards}), and the profit rate which
miners get from current submissions is $y(t) = S(x(t))f(x(t))$.

\subsection{Constant storage price}
\subsection{State-dependent storage price}
\begin{figure}
    \includestandalone[width=\textwidth]{figures/dynamics}
    \caption{
        \label{fig:dynamics} Dynamics of the state size for various initial
        rates. The numbers above the curves are the miners reward rates with
        respect to maximal possible stationary rewards.
    }
\end{figure}

\end{document}
