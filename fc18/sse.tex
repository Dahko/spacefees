\documentclass[]{llncs}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
\graphicspath{{./figures/}}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{standalone}
\usepackage{pgfplots}
%% The amsthm package provides extended theorem environments
%\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{tikz}

\usepackage{listings}

\usepackage{hyperref}

\usepackage{systeme}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1\textcolor{blue}{ #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes:}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{red}{Dima notes:}}{#1}}}
\newcommand{\vk}[1]{{\authnote{\textcolor{red}{V:}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}

\title{On Space-Scarce Economy\\ In Blockchain Systems}

\author{Alexander Chepurnoy \and Vasily Kharin \and Dmitry Meshkov}
%\institute{IOHK Research}
\maketitle

\begin{abstract}

In this paper we study space-scarce economy in massively replicated open
blockchain systems. In these systems, such as Bitcoin, memory to hold a current
state snapshot needed to validate transactions becomes the most scarce resource
eventually. The issue is even more critical for blockchain systems used to store
data~(votes, certificates, logs etc.). Uncontrolled state size growth could lead
to security issues, such as denial-of-service attacks. Only technical solutions,
not economic, have been proposed to tackle this problem to the moment. In
contrast, we propose to add a new component to a transaction fee scheme based on
how much additional space will be needed for new objects created in result of
transaction processing and for how long they will live in the state. We provide
three possible options towards implementing the new fee component, namely
\textit{prepaid outputs}, \textit{postpaid outputs} and \textit{scheduled
payments}. We provide an analysis of the model with respect to all the three
options. We show that the state growth could be bounded by a fee factor, miners
are getting additional stable rewards and lost coins are being taken back into
circulation eventually.    

\end{abstract}

\section{Introduction}

Bitcoin~\cite{Nakamoto2008} was introduced in 2008 by S. Nakamoto as a purely
peer-to-peer version of electronic cash with a ledger written into blockchain
data structure securely replicated by each network node. Security of the scheme
is relied on mining process. If majority of miners are honest, then Bitcoin
meets its security goals as formal analysis~\cite{Garay2015} shows. For work
done a miner is claiming a reward which consists of two parts. First, some
constant number of bitcoins are created out of thin air according to a
predefined and hard-coded token emission schedule. Second, a miner claims fees
for all the transactions included into the block. A transaction fee is set by a
user during transaction creation. Transaction fees are useful for an existing
cryptocurrency economy for two reasons:

\begin{enumerate}
  \item{\em Incentivization of miners.} A rational Bitcoin miner does not
      include all the valid transactions into blocks as, due to the increased
      chances of orphaning a block, the cost of adding transactions to a block
      could not be ignored~\cite{andersen2013,rizun2015transaction}. As shown
      in~\cite{rizun2015transaction}, even in absence of block size limit,
      Bitcoin fee market is healthy and the miners surplus is maximized at a
      finite quantity of block space. Thus the miner is incentivized to produce
      a block of a limited size. This means that only a subset of transactions
      which provides enough value to a miner will be included in a block. A
      paper~\cite{rizun2015transaction} provides a procedure to calculate
      transaction fee based on block propagation time.

  \item{\em Limit resources usage and prevent spam. } Besides of network
      utilization, transaction processing requires a miner to spend some
      computational resources. For most of the cryptocurrencies, a transactional
      language is limited~(with Bitcoin Script~\cite{script} being one of the
      most limited), thus a number of CPU cycles needed to process a transaction
      is strictly bounded and corresponding computational costs are not directly
      considered. In contrast, in cryptocurrencies supporting smart contract
      languages, such as~\cite{seijas2016scripting,tezosScript,solidity},
      transaction processing may require a lot of computations, and
      computational costs are included in transaction fee. This cost is specific
      to concrete transactional language and is out of scope of this paper.
\end{enumerate}

A transaction in Bitcoin fully spends outputs from previous transactions, and
also creates new outputs of user-defined values. A notable and the only
exception is a coinbase transaction of a block which creates fixed amount of
money out of thin air and also claims transaction fees without referring to any
outputs~(a fee for a non-coinbase transaction is sum of claimed outputs values
minus sum of values for created outputs). A node is checking a transaction in
Bitcoin by using a set of unspent outputs. In other cryptocurrencies a
representation of a {\em state} needed to validate and process an arbitrary
transaction could be different~(for example, in Ethereum~\cite{ethyp} such
structure is called the {\em world state} and fixed by the protocol). To process
a transaction quickly, the state~(or most accessed part of it) should reside in
random-access memory. Once it becomes too big to fit into RAM an attacker can
perform denial-of-service attacks against cryptocurrency nodes. For example,
during attacks on Ethereum in Autumn, 2016, an attacker added about 18 million
accounts to the state~(whose size was less than 1 million accounts before the
attack) and then performed succesful denial-of-service attacks against the
nodes\cite{eth2016dos}. Similarly, in 2013 a denial-of-service attack against
serialized transactions residing in a secondary storage~(HDD or SSD) was
discovered in Bitcoin\cite{vasek2014empirical}.

The main purpose of this paper is to consider a new mandatory component in a
transaction fee scheme reflecting state growth. In all known cryptocurrencies of
today, an element of the state once created lives possibly forever without
paying anything for that. This leads to continuously increasing state~(we point
to Bitcoin unspent transaction outputs~(UTXO) set size as an
example~\cite{utxoChart}). Moreover, state may grow fast during spam attack, for
example, 15 million outputs were quickly put into UTXO set during spam attacks
against Bitcoin in July 2015~\cite{bitcoin2015flood}, and most of these outputs
are not spent yet. The paper~\cite{reyzin2016improving} is proposing a technical
solution for non-mining nodes where only miners hold the full state~(assuming
that they can invest money in  random-access memory of sufficiently big
capacity), while other nodes are checking proofs of state transformations
generated by miners, and size of a proof (in average and also in a worst case)
is about $log(S)$ in regards with a state size $S$. Nevertheless, big state
could lead to centralization of mining or SPV mining~\cite{spvMining}, and these
concerns should be addressed. Also, there is an increasing demand to use a
blockchain as a data storage, and storing permanently objects in the state
without a cleaning procedure is not a viable option.

We propose an economic solution to the problem of unreasonable state growth
(such as spam attacks, or objects not being using anymore but still living in
the blockchain). The solution is a new mandatory fee component. We state that a
user should pay fee for both the additional space needed to store objects
created by a transaction, and also for lifetime of new bytes. This model is
usual for cloud storage services where users pay for gigabytes of data per
month. We provide a possibility for miners to control their storage requirements
by changing a fee factor. Later in this paper we will refer to this new fee
component as to a {\em space-time fee}.

Proposed fee regime is promoting money circulation in the blockchain economy.
The limited lifetime of a state element also leads to lost coins being taken
back into circulation~(supposedly by miners). 

Summarizing, we study an economy where quick-access storage of a node in a
massively-replicated system becomes the most scarce system resource eventually.
Thus we call such an economy a {\em space-scarce economy}.

\subsection{Assumptions}
Here we provide assumptions our model is based on:

\begin{itemize}
  \item{} all the fees for a block are going to a single miner like in Bitcoin.
      There are proposals to share the rewards for a block within a group of
      miners, for example in~\cite{eyal2016bitcoin,kogias2016enhancing}, and
      they are out of scope of the paper.
  \item{} a state is a set of unspent outputs. An output is not modifiable so
      can be only created and then spent at whole. 
  \item{} an output is protected by a spending condition which is defined as a
      logical formula. Predicates in the formula can refer to properties of a
      blockchain (for example, its current height available via variable
      $Height$), spending transaction $tx$ and the output $out$ itself. We
      assume that it is possible to compare two scripts, and also it is possible
      to determine whether the spending transaction contains an output with a
      given property. For example, $tx.has\_output(script = out.script)$
      evaluates to true if the spending transaction contains an output with the
      same script as the output has. Note that Bitcoin Script is too limited to
      support scripts comparison as well as using the spending transaction and
      the output to spend in a spending condition.
  \item{} for simplicity, we assume that a block is of a finite size but all the
      transactions a miner has at a moment of block generation can be packed
      into it, if otherwise is not stated explicitly.
  \item{} time is measured via \textit{height} which is a number of blocks since
      an initial block~(a genesis block) till a block of interest. 
  \item{} all anyone-can-spend outputs are collected by miners immediately as
      they appear.
  \item{} we are considering minimal mandatory fees in the paper. All the nodes
      are checking that a fee paid by a transaction is not less than a minimum
      and rejecting the whole block if it contains a transaction violating fee
      rules. Thus a fee regime is considered as a part of consensus protocol in
      our work. A user can pay more than the minimum to have a higher priority
      for a transaction of interest.   
\end{itemize}

\subsection{Structure of the paper}

%The paper is organized as follows. A design of our new fee component is
%provided in Section~\ref{sec:model}. The model then is analyzed in
%Section~\ref{sec:analysis}. In Section~\ref{sec:rel-work} we observe related
%work, and in Section~\ref{sec:further-work} we shape a plan for further
%research.

\section{Algorithm of the fee assignment}

In spite of the problems and the possible solution outlined in the introduction,
the essential element of the space-scarce economy is the method of assigning the
fee to every transaction \vk{or block?} in a sensible way. In this chapter we
start by a reasoning about the guiding principles for the fee assignment, and
end up with the example of a practical fee assignment protocol.

The evolution of the blockchain networks has demonstrated the main obstacles for
the system to be truly distributed in the real world. First and the most
important so far, the storage capacity of the nodes is limited. In patircular it
makes running a full node almost impossible on a desktop hardware in a system,
where the full blockchain is needed for the node operation \vk{more details}.
Elegant solutions have already been found for this problems in recent years
\vk{citations}, consisting in parctical unnecessity of storing the blockchain
itself, but rather parts of header chain, and the state described above.
However, the part of this vulnerability remains, as a possibility of flooding
the state with a long list of UTXO, which are never spent. This also has a side
economical effects, since coins from lost (accidentally or intentionally) UTXO's
are never returned to the circulation, and it becomes important if the total
amount of coins is unchanged.

Second, it became obvious, especially with the development of smart contracts,
that a transaction ``cost'' for the node can be more than just a storage:
transactions can contain relatively complicated scripts which are meant to be
executed by the nodes, providing additional overhead. The extreme and most
famous example is the Ethereum network with the concept of the ``World
Computer''. As we are trying to provde the economical solution for
decentralization up to the pocket device scale (at least up to the smartphones),
the aspect of heavy calculations should be also taken into account.

Third, there is the network load created by every transaction. If
the output is created in one block, and spent right in the next one, it provided
almost zero overhead in terms of storage, but created the basic network load
needed for synchronization.

From the prospective presented in the introduction, the transaction fee must
incorporate all three of these aspects. The storage--oriented transactions should
be charged for storage, the computation--oriented transactions should be charged
for script execution, and all the others --- by the minimal transaction fee for
the network load. The last sentence can be formalized in its simplest form as follows:
\begin{equation}
    \operatorname{Fee}(tx) = \max(\alpha N_b(tx), \beta N_c(tx),
    S(state,tx)L[tx])\,.
    \label{eq:max}
\end{equation}
Here $\alpha$ and $\beta$ are the pricing coefficients, $N_b$ is the
number of bytes in the transaction, which defines the network load, $N_c(tx)$ is
the estimate of the computational cost of transaction, $S(state,tx)$ is the cost of
the storage of outputs in the state for the unit of time, $L([tx])$ is the time which
transaction is being stored in the state. \vk{Oops. Do we mean now that if the
    transaction frees the space in the state, the corresponding output can be
stored forever? If yes, it cancels vast part of the reasoning: I create $tx_0$ with
two outputs; in the next block $tx_1$ merging them, and store the output of
$tx_1$ for free.} The obvious problems here are: What are the guiding principles
for choosing $\alpha$, $\beta$ and $S$? How to arrange the charging for state
spacetime consumption, if transaction contains no information on when the
outputs will be spent? We address these problems in the following sections.
There is also the problem of estimating $N_c(tx)$, which is extremely hard \vk{or
unsolvable?} \vk{How hard, does anybody know the specific name of this problem?}
for the Turing--complete languages, however solvable with the restrictions on the
language\vk{citations, which restrictions, or stick to one existing}. We leave
it beyond the scope of the paper.

\subsection{Choice of the relative values of $\alpha$, $\beta$, $S(tx)$}

Assume for now, that for every transaction we know the time the outputs will be
stored in the state $L[tx]$. We will overcome this difficulty later. Based on
Eq.~\eqref{eq:max}, we come up with the notion of space of transactions, which
is three--dimensional in our case --- every transaction is defined by three
numbers: $N_b(tx)$, $N_c(tx)$, $N_s = S(tx)L[tx]$. Eq.~\eqref{eq:max} provides a
prescription of splitting this space into three regions: network--oriented
transactions, space--oriented transactions, and computation--oriented
transactions (see Fig.~\ref{fig:max}). All the splitting is governed by the
direction of vector $\vec{n}$ definig the line $\alpha N_b=\beta N_c=N_s$.
Varying the coefficients $\alpha$ and $\beta$, one can change the direction of
$\vec{n}$ adjusting the formal fee prescription to the sensible values.\vk{It
    would be good and convincing to get some actual data from the existing
network.}
\begin{figure}
    \center
    \begin{tikzpicture}[rotate around y=-30]
        \draw[thick,-stealth] (0,0,0)--(0,0,6) node [below] {$N_c$};
        \draw[thick,-stealth] (0,0,0)--(0,6,0) node [right] {$N_b$};
        \draw[thick,-stealth] (0,0,0)--(6,0,0) node [below] {$N_s$};
        \draw[thick,-stealth,red] (0,0,0)--(4,4,4) node [above] {$\vec{n}$};

        \coordinate[label=$O$] (O) at (0,0,0);
        \coordinate[] (X) at (5,5,5);
        \coordinate[] (A) at (0,5,5);
        \coordinate[] (B) at (5,5,0);
        \coordinate[] (C) at (5,0,5);

        \draw plot [mark=*, mark size=1] coordinates{(5,2.3,2)} node[above]
        {space-oriented $tx$};
        \draw plot [mark=*, mark size=1] coordinates{(3,2.2,5)} node[above]
        {computation-oriented $tx$};
        \draw plot [mark=*, mark size=1] coordinates{(1,4,1)} node[above]
        {network-oriented $tx$};

        \draw[fill=blue,opacity=0.3] (X)--(A)--(O);
        \draw[fill=red,opacity=0.3] (B)--(X)--(O);
        \draw[fill=brown,opacity=0.3] (X)--(C)--(O);
        \draw[dashed] (A)--(0,0,5);
        \draw[dashed] (A)--(0,5,0);
        \draw[] (O)--(0,6,6);
        \draw[dashed] (B)--(5,0,0);
        \draw[dashed] (B)--(0,5,0);
        \draw[] (O)--(6,6,0);
        \draw[dashed] (C)--(5,0,0);
        \draw[dashed] (C)--(0,0,5);
        \draw[] (O)--(6,0,6);
    \end{tikzpicture}
    \caption{Space of transactions splitted by
        Eq.~\eqref{eq:max} into the subregions of the dominant fees.\label{fig:max}}
\end{figure}

\subsection{Choice of $S(tx)$}

The simplest way of assigning the value of $S(tx)$ is by making it proportional to
the amount of data to be written into the state. That is, specifying the price
of storage of 1 byte of data per one day. However, as it is shown in the
Appendix, this does not fully solve the problem of limiting the state size. What
is being controlled in this case, is the rate at which the data is being
submitted, but not the state size itself. One could also manually define the
maximal volume of the state for the network. This solution, in turn, has its own
caveats. For example, once the state is kept (almost) full by the participants,
it can be (almost) impossible to submit the transaction increasing the state size.
The time till it becomes possible is hardly predictable. 

Preferrable properties of the current state size could be formulated as follows:
it should be predictable, stable, and below some externally given value (upper
restriction on state size, being unique for the whole network). 

Another natural question arising is whether the rigid state size restriction is
necessary?  It is easy to imagine the situation where the formal possibility of
exceeding the state is still present, but hardly ever being used. For example,
if one wants to constrain the state size to 10MB, the possible solution is to
set normal price for submitting data to store if the state size after submission
is below 10MB, but some astronomical price for the luxury of storage above 10MB.
So, formally it will be possible, but in fact, hardly ever used, with every
usage bringing significant profit to miners. The generalization of this idea is
to form the explicit dependence of price on the state load (it will referred to
as ``pricing curve''). The good pricing curve must provide at least one stable
equilibrium of the state size; the minimal dependence on initial conditions (if
possible), and high rewards for miners. The latter could serve as good
optimization parameter. Extreme cases are zero price -- huge data submission --
miners get nothing; and infinite price -- zero data submission -- miners get
nothing. As usual, the maximal outcome is between.  The pricing policies
described above are two particular cases of pricing curve (see
Fig.~\ref{fig:steps}). The values of $S(tx)$ and $p(x)$ are connected via
\begin{equation}
    S(tx)=\int_x^{x+\Delta(tx)}p(y)\,dy\,,
    \label{eq:Sp}
\end{equation}
where $x$ is the current state load, $\Delta(tx)$ is the change of the state
size by transaction $tx$. \vk{How to order transactions in the block? Is it Ok
to use the difference? What if it is negative?}.
\begin{figure} 
    \hfill 
    \begin{tikzpicture} 
        \draw[->] (0,0) -- (0,3) node [right]{$p(x)$}; 
        \draw[->] (0,0) -- (5,0) node [above]{load}; 
        \draw[very thick] (0,0.3) -- (3,0.3) -- (3,3); 
        \draw[dotted] (3,1) -- (3,0) node[below]{$10$MB}; 
    \end{tikzpicture} 
    \hfill 
    \begin{tikzpicture} 
        \draw[->] (0,0) -- (0,3) node [right]{$p(x)$}; 
        \draw[->] (0,0) -- (5,0) node [above]{load}; 
        \draw[very thick] (0,0.3) -- (3,0.3) -- (3,2) -- (5,2); 
        \draw[dotted] (3,1) -- (3,0) node[below]{$10$MB}; 
    \end{tikzpicture} 
    \hfill 
    \caption{ 
        Examples of pricing curves: rigid state size restriction (left) and 
        overflow fees (right, see text). The value of $10$MB is taken 
        arbitrarily. 
        \label{fig:steps} 
    } 
\end{figure} 

Note that the pricing curve is defined by a small number of parameters and
fixed the same for all the network. To impose the upper restriction on the state
size one can choose the pricing curve formally going to infinity at some finite
state size. One can also try to estimate the optimal state size for a given
differentiable pricing curve. In the continual with the assumptions
described in the appendix, the data submission rate $N(p(x))$ is fully defined by the
current storage price $p(x)$.  Rewards rate obtained by the miners for stable
state size at price $p$ is given by $y=pN(p)$. Example is provided at
Fig.~\ref{fig:rewards} First, it provides a possible method of measuring
explicit form of the function $N(p)$ in the model: one has to set up the price,
and observe the static rewards. Second, one may wonder about the price $p^*$,
optimal for the miners in terms of rewards. Obviously, it satisfies
$N(p^*)+p^*N'(p^*)=0$, where prime is derivative with respect to price. As
usual, the optimal price here does not depend on the pricing policy, but rather
the implicit property of the network.  Having the price varying freely can be
considered beneficial both for miners and for network as a whole, since it
allows the first ones to optimise signing strategy, and with this given the
state size is automatically adjusted to the relatively predictable level
$p^{-1}(p^*)$.

\begin{figure}
    \includestandalone[width=\textwidth]{figures/rewards}
    \caption{
        \label{fig:rewards} Rewards curve.
    }
\end{figure}

\subsection{Example of pricing curve}
From what was said above, the conclusion is that two values are particularly
important for the model: maximal state size, and optimal price. In order to
preserve the limitation on the stored amount of data, one can let the storage price go to infinity
faster than $1/x$ moving closer to the limiting size. On the other side, there
may be some intermediate ``preferred'' size of the state $x_d$. This, in turn,
can be matched to the optimal price. One may also wish to introduce the lower
bound on the storage price $p_{min}$. Taking these values it is easy to
construct the function $p(x)$ with the desired properties. As an example,
\begin{equation}
    p(x) = p_{min}+(p^*-p_{min})\frac{x}{x_d}\frac{x_{max}-x_d}{x_{max}-x}\,,
    \label{eq:sample_price}
\end{equation}
Another question is how one should deal with the chunks of data comparable to
the state size. The logical way is to treat $p(x)$ as the differential property
(which it actually is). So if the current state size is $x_0$, and the
participant is willing to submit the data block of size $L$ for unit time, he is
charged by the amount of $\int_{x_0}^{x_0+L}p(x)\,dx$. For the sample pricing
curve it is
\begin{equation}
    P = L\left(p^*-\eta \Delta p \right)
    -
    \eta(\eta-1)\Delta p\, x_d
    \log\left(1-\frac{L}{x_{max}-x_0}\right)\,,
    \label{eq:sample_chunk}
\end{equation}
where $\eta=x_{max}/x_d$,$\Delta p=p^*-p_{min}$. Note that the logarithmic
divergence guards the upper size limit.

\subsection{Unknown storage time}
\vk{Here --- Dima's idea as we discussed it in Moscow. Q: postpaid, or
pay-as-you-go?}
\begin{figure}
    \center
    \begin{tikzpicture}
        \draw[thick,-stealth] (0,0)--(6,0) node [below] {$t$};
        \draw[thick,-stealth] (0,0)--(0,3) node [right] {Fee};
        \draw[thick, dashed] (0,0)--(2,1);
        \draw[dashed] (2,1)--(2,0) node [below]{subsidized period};
        \draw[thick,blue] (0,1) node[left] {\textcolor{black}{$\max(\alpha
        N_b,\beta N_c)$}} --(2,1) -- (5,2.5);

    \end{tikzpicture}
    \caption{Transaction cost as a function of output existance time.\label{fig:max_t}}
\end{figure}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\appendix
\section{State size dynamics}
For the primary analysis assume that participants act honestly: they submit
data if they need to do so and it is affordable; they do not in the opposite
case. For the sake of simplicity, suppose that the time of storage of data
block is fixed, and equal to $T$. In order to reduce the discrete stochastic
model to continuous deterministic one, assume that the number of participants
is large, and the typical size of the submitted data chunk is much less than
characteristic pricing curve variation scale. The amount of data submitted to
the state is changing continuously. At every given moment of time the users
submit the data at some rate (say, MB/s) $f$, which is defined by the current
price (participants submit more when cheap, and less when expensive). The
current price is fully determined by the current state load $x$. After time
interval $T$ data is erased from the state. The data is written into the state
at rate $f(x(t))$, and erased at rate $f(x(t-T))$. Under these assumptions,
the evolution of the state load is defined by the following equation:
\begin{equation}
    \frac{dx}{dt} = f(x(t))-f(x(t-T))\,.
    \label{eq:dde0}
\end{equation}
If one measures time in the data block TTL $T$, the equation takes the form
\begin{equation}
    \dot{x} = f(x(t))-f(x(t-1))\,.
    \label{eq:dde1}
\end{equation}
The equations of this type are called delay differential equations (DDE), and have
been studied widely for the vast amount of control problems.

Now few words about the function $f$, and how to convert it to the miner's
income. What participants know is the pricing curve $p(x)$. For every value $P$
of this function there is amount of people $N(P)$ who want to submit data and
can afford it at time interval $T$. The function $N(P)$ is non-increasing, and
going to zero for sufficiently large $P$ (every participant has maximal price he
is ready to pay, and will also try to submit something if current price is
lower; for sufficiently large price no one is ready to pay). In these notations
$f(x)=N(p(x))$ (see inset on Fig.~\ref{fig:rewards}), and the profit rate which
miners get from current submissions is $y(t) = p(x(t))f(x(t))$.

\subsection{Constant storage price}
\subsection{State-dependent storage price}

\end{document}
