\documentclass[]{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\newtheorem{axiom}{Axiom}

\usepackage{systeme}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}


\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{blue}{Dima notes}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\esse}{\textit{Esse}}
\newcommand{\state}{\textit{State}}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\begin{document}

\title{On Space-Scarce Economy In Blockchain Systems}
\author{Dmitry Meshkov and Alexander Chepurnoy, IOHK Research}
\maketitle

\begin{abstract}
In this paper we study space-scarce economy in massively replicated open blockchain systems, like Bitcoin. In such systems, memory to hold the balance sheet becomes the most scarce resource eventually. Currently only technical solutions, not economic, are proposed in order to tackle the problem. The problem becomes even harder for blockchain systems used to store data~(votes, certificates, logs etc.). We propose to add a new component to a fee regime, fees based on how much additional space will be needed for the balance sheet in result of transaction processing, and fow how long newly created records will live.    
\end{abstract}

\section{Introduction}

Bitcoin \cite{Nakamoto2008} has been invented in 2008 by Nakamoto as a purely peer-to-peer version of electronic cash. 

\dnote{more words about bitcoin as an economy}

Any cryptocurrency should satisfy at least 2 properties assuming an honest majority and arbitrary adversarial behavior \cite{Garay2015}. \textit{Persistence} guarantees that once a transaction goes more than $k$ blocks "deep" into the blockchain of one honest player, then it will be included in every honest player's blockchain with overwhelming probability, and it will be assigned a permanent position in the ledger. \textit{Liveness} guarantees that all transactions originating from honest participants will eventually end up at a depth more than $k$ blocks in an honest player's blockchain, and hence the adversary cannot perform a selective denial of service attack against honest account holders.

Bitcoin satisfies \textit{Liveness} property when honest miners are expected to be altruistic and adds transactions to blocks even if it's not profitable for them. However, a rational miner won't include all valid transactions into blocks, because due to the increased chances of orphaning a block, the cost of adding transactions to block is not negligible\cite{rizun2015transaction, andresen2013}. As shown in \cite{rizun2015transaction}, even in absence of block size limit, Bitcoin fee market is healthy and the miners surplus is maximized at a finite quantity of block space, and thus the miner is incentivized to produce a block of a limited size. This means, that only subset of transactions, providing enough fee for miners will be included in blocks and both miners and users needs explicit rules how to calculate transaction fee in current environment. \knote{Isn't this claim way too bold and unproven?} \cite{rizun2015transaction} provides a procedure to calculate transaction fee based on block propagation time, i.e. miners network resources utilization. We argue, that this is not the only component of the transaction fee, because miner also utilize other his resources that should be considered.

Besides of network utilization, transaction processing requires computations from miner. For most of cryptocurrencies transactional language is limited \cite{script}, their validation is very fast and this cost may not be considered, but for cryptocurencies with rich transaction language \dnote{more links e.g. for sigma-state} this cost is not negligible. In so-called smart contract languages \cite{seijas2016scripting, tezosScript, solidity} transaction processing may require a lot of computations and computational costs are included to transaction fees there. This cost is specific to concrete transactional language and is out of scope of this paper.

The main purpose of this paper is to consider third component of the transaction fee, that is related with increasing local miners \state{}. In all known cryptocurrencies, when a miner accepts a transaction that increases it's current \state{}, he takes on a liability equal to the present value of the cost of storing those new outputs indefinitely far into the future. This in not healthy situation that is leading to continuously increasing \state{} \cite{utxoChart}, e.g. number of unspent transaction outputs increases by 12000 every year in Bitcoins. Moreover state size may increase very fast during spam attack, e.g. 15000 additional outputs where added to Bitcoins UTXO during spam attacks in July 2015 \cite{bitcoin2015flood} and most of this outputs are not spent yet. Thus miner's \state{} may significantly increases during attacks and this attacks are free for adversary, meaning that transaction fee for increasing \state{} size is 0. Note, that for efficient block processing, \state{} should be kept in memory, otherwise attacks where miner generate block that will be validated for a long time by other miners come into being \dnote{link to ethereum DoS, + others?}. Big \state{} size leads to centralization, where hardware requirements are too big for common users, and to SPV mining, where miners are tring to generate a new block without transaction validation of previous one. In July 2015 this resulted in invalid chain of 6 blocks\cite{spvMining}, that is enough to perform double-spend attack in most of Bitcoin applications. To prevent \state{} growing, this third fee component should depend from size of inputs, destroyed by this transaction, size of outputs, create be it and their expected time to live. Later in this paper we will call it a \textit{state space-time fee}.

In this paper we propose a model, where users should pay fee for multiplication of the time output data should be kept in \state{} to it's size. This is very usual for most of storage services, where users pay for the gigabyte of data per month. Such an approach prevents putting any data to miners storage forever, leading to situation, where miners can control their \state{} size with fee. Our model design is described in section~\ref{sec:model} while it's consequences for cryptocurrency economy are described in section~\ref{sec:analysis}.  \dnote{paper structure}

\dnote{write somewhere about lost coins and deflation}

\section{The Model}
\label{sec:model}

Most of users think about blockchain as something enough for a fullnode to work successfully~(and efficiently). In fact, the blockchain itself is not enough for performance and even security reasons. Nodes in Bitcoin are holding a set of unspent outputs in order to validate efficiently an arbitrary transaction. Similarly, Ethereum\cite{ethyp} has a concept of "world state", and some aspects of a particular state representation are inbuilt into the protocol. \esse{} model is based on \state{}-centric design and have the main purpose to make \state{} size controllable by miners.

As we have already mentioned above, in our model transaction fee consists of 3 parts: \textit{validation cost}, \textit{propagation cost} and \textit{state space-time difference cost}.

\begin{equation}
fee = fee_{validation} + fee_{propagation} + fee_{space\_time}
\end{equation}

 \dnote{should we require from total fee to be positive?}

Validation and propagation costs are strictly positive, and assumed to be independent from space-time fee. We also assume, that space-time fee impact to total fee may range from negligible to dominant. Space-time fee component may be both positive and negative, since transaction may both increase and decrease \state{} size. It's dependency from size of inputs, outputs and their time to live may vary depending on the cryptocurrency purpose. Any transactoin remove some data from state, freeing some space-time \textit{$T_{cleared}$} and add some data to it, filling space-time \textit{$T_{filled}$} and resulting space-time fee can be calculated as follows:

 \dnote{May be it's better just mention, that user should pay for space-time of all his outputs}

\begin{equation}
fee_{space\_time} = K \cdot (T_{filled} - T_{cleared})
\end{equation}

where \textit{K} is a space-time price in the fee tokens. This price depends on hardware price for miners and token exchange rate, so \textit{K} is not a static value. We assume, that miners can change this pricing via mechanism like ``gas'' in Ethereum and thus control cost of blockchain support.

In most of existing cryptocurrencies it's not clear, how to calculate $T_{filled}$ and $T_{cleared}$. Sizes of old and new outputs are known, while it is not possible to calculare expected in existing blockchain setups. To do this, transactional language should support both regular cryptography operations, like signature validation, and environment operations, like blockchain height and transaction, that is trying to spend this output. Later we assume cryptocurency, that support this operations, and will try to analize different variants of $fee_{space\_time}$ dependency. In all of them $T$ is proportional for multiplication of the time output data should be kept in \state{} to it's size, while concrete rules how to enforce user to pay space-time fee are different.

\subsection{Prepaid outputs}

First model we are going to analyze is prepaid outputs. In it each output represents a box of fixed size \textit{B} in a \state{} and prepaid until explicitly known period of time $L_{max}$. After $L_{max}$ anyone ~(presumably miner, generated first block after that) will be able spend this overdue output. Thus spending script for all outputs will be a combination of regular spending script and loan period $L_{max}$:

\begin{equation}
(Height > L_{max}) \lor (regular\_script)
\end{equation}

where \textit{Height} is current blockchain height and \textit{regular\_script} is user-defined output spending script. This lifetime part of a script is a part of consensus, and space-time transaction fee is paid at the time of output creation:

\begin{equation}
fee_{prepaid} = K \cdot (\sum_i{(B_i \cdot (L_{max\_i} - Height))} - \sum_j{(B_j \cdot (L_{max\_j} - Height)}))
\end{equation}

\subsection{Postpaid outputs}

In the second model, user should pay fee for taken space-time in \state{} when he spends output. When output is spent it's lifetime is known, so resulting transaction fee can be calculated:

\begin{equation}
fee_{postpaid} = \sum_i{(K_i \cdot B_i \cdot (H_{spent\_i} - H_{creation\_i}))}
\end{equation}

where $H_{creation\_i}$ and $H_{spent\_i}$ are heights, where i-th output was created and spent respectively. Note, that each output has it's own space-time \textit{$K_i$}, corresponding to \textit{K} value at it's creation time. Here we can note, that if output value is \textit{V}, then height \textit{$H_{max}$} exists, where all the output value will be taken by space-time fee.

\begin{equation}
H_{max} = {H_{creation} + {V \over {K \cdot B}}}
\end{equation}

After that anyone should be able to spend this output, sending all it's value to transaction fee and spending script will looks like

\begin{equation}
(Height > H_{max}) \lor (regular\_script)
\end{equation}

\subsection{Demurrage balance}

The last model we are going to analyze is a combination of prepaid and postpaid models. Like in postpaid model, user pays for each his output when we spends it in an outgoing transaction, but is enforced to move his coins before a known time $H_{creadion} + H_{demurrage}$. If the user do not do this, anyone can create a transaction with this output, returning them to owner without space-time fee ${K \cdot B \cdot H_{demurrage}}$. In this model $H_{demurrage}$ is another protocol parameter, that may be fixed by protocol design or changed via miners voting like \textit{K}.

\section{Analysis of The Model}
\label{sec:analysis}

In this section we are going to provide comprehensive analysis of \esse{} model. Besides of it's main goal to control state size, it provides additional benefits as side-effects, that can be used in cryptocurrency design. Our further analysis will be based on the following stats from current Bitcoin network:

\begin{itemize}
  \item Number of unspent transaction outputs: $N_{UTXO} \approx 45000000$
  \item Number of coins in circulation: $N_{coins} \approx 16000000$ BTC
  \item Mean number of coins in one output: $V_{output} \approx 0.35$ BTC
  \item Simple payment transaction fee: $fee_{propagation} \approx 0.0002$ BTC
  \item Mean output size: $B \approx 36$ Bytes
  \item Per cent of coins, moved in every block: $M_{flow} \approx 0.013$ \%
  \item Time interval between blocks: $T_{block} \approx 10$ minutes
  \item Transaction fees per block: $M_{pg} \approx 1$ BTC
  \item Fixed block reward: $R_{f} \approx 12.5$ BTC
\end{itemize}

\subsection{Money flow}
\label{sec:flow}

From users point of view, the longer you keep some output, the bigger space-time fee you pay. Thus \esse{} provides an incentive to move your coins stimulating economic activity. In all fee models, described in section~\ref{sec:model}, user pays ${K \cdot B}$ coins every block for keeping his output into \state{}. If he use blockchain with \esse{} as a money chain, output size \textit{B} is relatively small and do not depend on output value.

To estimate money flow let's assume, that user will move his money when space-time fee will start dominate over other transactional costs \dnote{why?}. Thus we can estimate expected mean output lifetime as

\begin{equation}
\label{eq:ltmean}
L_{mean}={fee_{propagation} \over K \cdot B}
\end{equation}

Since there are $N_{UTXO}$ in a system and each of them contains $V_{output}$ coins, we can estimate number of transactions per block incentivized by \esse{} model:

\begin{equation}
N_{transactions} \approx {N_{UTXO} \over L_{mean}} = {N_{UTXO} \cdot K \cdot B \over fee_{propagation}}
\end{equation}

and per cent of coins, that will be moved in each block:

\begin{equation}
M_{flow} \approx { N_{transactions} \cdot V_{output} \over N_{coins}} = {K \cdot B \over fee_{propagation}}
\end{equation}

Thus, money flow may be controlled with \textit{K} parameter. This formula provide a way to estimate \textit{K} based on current Bitcoin statistics:

\begin{equation}
K={M_{flow} \cdot fee_{propagation} \over B} \approx {10^{-9}} ({BTC / (Byte \cdot Block)})
\end{equation}

For regular outputs of 36 Bytes space-time fee part will exceed propagation fee after 5555 blocks or 38 days. This means, that for active users, who spend their money more often than once a month, space-time fee will be negligible relative to propagation fee.

From money flow analysis we can find out how to use \esse{} model to control cryptocurrency money flow, changing space-time price and encourage active economy participants. Another money flow analysis result is the dependency between $L$ and $K$ \ref{eq:ltmean} that can particularly by used in the \textit{Demurrage balance} model to reduce number of model parameters.

%Considering total $1.6\cdot10^7$ of Bitcois in c circulation, we can conclude, that user should pay for about $6\cdot10^{-17}$ of total supply every block for every byte in output.

\subsection{Lost coins recirculation}
\label{sec:re}

The need of recirculating lost coins was widely discussed in cryptocurrencies \cite{gjermundrod2014recirculating, gjermundrod2016going} in order to combat deflation that will inevitably occur in cryptocurrencies with the fixed amount of coins to be circulated. Coins declared supply is known by cryptocurrency design, but available supply is unknown due to lost coins, locked in outputs that will never be spent \cite{ron2013quantitative}. On the other hand deflation is a real problem in the traditional monetary system, but it is still open question, whether it will also be a problem in the Bitcoin economy \cite{bitcoinDeflationarySpiral, barber2012bitter}.

While negative impact of deflation to cryptocurrencies is not proven, most of researchers agree in need of lost coins recirculating. \esse{} model provide lost coins recirculation mechanism by design, while it's properties vary from model implementation and parameters. In this section we are going to estimate lost coins recirculation dependency from chosen model and it's parameters.

Fee for keeping output of size \textit{B} is the \state{} for \textit{L} blocks is ${K \cdot B \cdot L}$. In \textit{Postpaid} and \textit{Demurrage balance} models space-time fee is taken from output value itself, so when keys for output with \textit{$V_{output}$} coins are lost, they will return to economy after \textit{$L_{max}$} blocks, where

\begin{equation}
{L_{max} = {V_{output} \over K \cdot B}}
\end{equation}

Maximum lifetime of a concrete outputs depends on miner-controlled \textit{K} parameter and user-defined output size and value. As in previous section we will estimate this dependency based on Bitcoin stats:

\begin{equation}
{L_{max} \approx {1 \over 100 \cdot K}}
\end{equation}

Based on this equation, it is possible to chose \textit{K} keeping in mind desired maximum ouptut lifetime. Desiring 10 years period of coins fully recirculation, \textit{K} parameter should equals $10^{-6}$ that is much bigger than $10^{-9}$ from previous section \dnote{$??? 10 is too small, you'll be able to spend only hlaf of your money after 5 years$}. Regarding lost coins recirculation, significant difference between \textit{Postpaid} and \textit{Demurrage balance} is that in \textit{Postpaid} all coins will return to economy all at once after some quite big $L_{max}$ period, while in \textit{Demurrage balance} they will return to economy by small portions during this period. This makes \textit{Demurrage balance} preferable to \textit{Postpaid}, because lost coins from big enough outputs in \textit{Postpaid} will not return to the circulation in foreseeable future. Anyway in a log-term equilibrium conditions coins recirculation rate of both models will be calculated as

\begin{equation}
R_{postpaid} = R_{demurrage} = {N_{lost} \cdot V_{output} \over L_{max}} = {N_{lost} \cdot K \cdot B}
\end{equation}

where $N_{lost}$ is the number of outputs with lost keys. Assuming current Bitcoins statistics and $N_{lost}\approx10^6$ we can estimate, that $\approx0.036$ BTC will be released from abandoned outputs keys every block.

In \textit{Prepaid} model user define $L_{max}$ by himself when he creates output and number of released coins after $L_{max}$ is equals to output value $V_{output}$ rater than much smaller space-time fee $fee_{space\_time}$. Note here, that $L_{max}$ do not directly depends on \textit{K} and coins recirculation rate will only depend on $V_{output}$, user-defined $L_{max}$ and number of lost outputs $N_{lost}$:

\begin{equation}
R_{prepaid} = {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

Let's assume user-defined coin recirculation period $L_{max}\approx10$ years and $K\approx10^{-9}$ from previous section, we can estimate difference between prepaid and postpaid models:

\begin{equation}
{R_{prepaid} \over R_{postpaid}} = { V_{output}  \over  K \cdot B \cdot L_{max}} \approx 20
\end{equation}

%R_{postpaid} = R_{demurrage} = {N_{lost} \cdot V_{output} \over L_{max}} = {N_{lost} \cdot K \cdot B} = 10^6 * 10^(-9) * 35 = 0.035
%R_{prepaid} = {N_{lost} \cdot V_{output} \over L_{max}} = 10^(6) * 0.36 /  = 0.684931507
%  \item Mean number of coins in one output: $V_{output}=0.35$ BTC
%   \item Simple payment transaction fee: $fee_{propagation}=0.0002$ BTC

 \dnote{Check, should be something like 1000}

Thus \esse{} model by design provide a way to return lost coins to circulation, preventing deflation risks. \textit{Postpaid} model has a disadvantage, that lost coins will be returned to circulation in a far future, in \textit{Prepaid} model coin recirculation rate is much higher than in other models and \textit{Demurrage balance} model is a smoother way of coin recirculation.

\subsection{Miner rewards}
\label{minerrew}
Mining reward is very important for cryptocurrency economy - in original paper \cite{Nakamoto2008} it's assumed, that miners are incentivized to fair behaviour, while recent researches showed, that it is not always correct \cite{carlsten2016instability, eyal2014}. In addition to usual propagation fee, \esse{} provides two new sources for miner income: a space-time fee and a coin recirculation reward.

\begin{equation}
M_{reward} = M_{propagation} + M_{space-time} + M_{recirculation}
\end{equation}

In section \ref{sec:flow} we have noticed, that \esse{} users have an incentive to actively use their coins and propagation reward is correlated with space-time reward:

\begin{equation}
M_{propagation} = C \cdot M_{space-time} + M_{pg}
\end{equation}

where $C$ is non-negative constant. Space-time miner reward depends on \state{} size and space-time price $K$ only:

\begin{equation}
M_{space-time} = \sum_{i=1}^{N_{UTXO}} K_i \cdot B_i \approx K \cdot N_{UTXO} \cdot B
\end{equation}

Recirculation reward was calculated in previous section and depends on space-time fee model. However it can be generalized as with $K_{model}$ parameter, that is equals to 1 for \textit{Demurrage balance} and \textit{Postpaid} models, and $K_{model} > 1$ \dnote{20?} for \textit{Prepaid} model:

\begin{equation}
M_{recirculation} = {K_{model} \cdot  N_{lost} \cdot K \cdot B}
\end{equation}

Resulting miner reward:

\begin{equation}
\label{eq:reward}
M_{reward} \approx M_{pg} + (K \cdot B) \cdot ((1 + M) \cdot N_{UTXO} + K_{model} \cdot N_{lost})
\end{equation}

First part of this equation $M_{pg}$ is the reward of miner in existing fee models, the rest is the unique reward for \esse{} model.  In a sensible assumption $N_{UTXO} >> N_{lost}$ equation \ref{eq:reward} can be simplified to

\begin{equation}
M_{postpaid} \approx M_{pg} + K \cdot B \cdot N_{UTXO} \cdot (1 + M)
\end{equation}

that allows to estimate such $K$, when additional \esse{} reward will exceed common propagation reward $M_{pg}$:

\begin{equation}
M_{postpaid} = {M_{pg} \over B \cdot N_{UTXO} \cdot (1 + M)} \approx 10^{-9} ({BTC / (Byte \cdot Block)})
\end{equation}

that is naturally coincide to estimations from section \ref{eq:ltmean} while both estimations are made from assumption, that propagation fee and space-time fee are equal for end users. Remarkable that space-time reward does not depend on network throughput and can be easily predicted. Since it will be accrued to generator of block with concrete height, it may be considered as a constant block reward fixing problem of blockchain instability without block reward \cite{carlsten2016instability}. It's value may be controlled by $K$ parameter making mining more stable and thus network more secure.

\dnote{What is an output value when miner is interested in collecting it?}

\subsection{Cryptocurrency inflation}

As we have already noticed in section \ref{minerrew}, miners reward from space-time fee can be considered as static block reward. Extending this idea it is possible to get rid of coinbase transactions breaking usual transaction rule that sum of inputs should not be less then sum of outputs. To achieve this, all coins should be issued in genesis block in such a way, that every block one output will be released and miner will collect it's value according space-time fee model. Thereafter miner will collect reward in uniform way collecting abandoned outputs, whenever it was created in genesis or by cryptocurrency user.

\subsection{State size}

Finally, we are going to analyze direct assignment of \esse{} model - to control \state{} size. Upper bound of \state{} size is $S$ may be easily calculated from assumption, that all available supply will be paid for space-time fee for one huge output to keep it in state for 1 block. However usually block size is limited by $S_{block}$ parameter and thus maximum output size is $B = S_{block}$. As soon as each block space-time fee $K \cdot B$ should be paid for all previously created outputs, maximum possible number of such outputs $O_{max}$ may be calculated from equation:

\begin{equation}
N_{coins} = \sum_i^{O_{max}}{K \cdot S_{block} \cdot i} = K \cdot S_{block} \cdot ( O_{max}^2 + O_{max}) / 2 \approx K \cdot S_{block} \cdot O_{max}^2 / 2
\end{equation}

assuming that number of unspent outputs is big enough. Resulting state size

\begin{equation}
\label{eq:statesizemax}
S = S_{block} \cdot O_{max} = \sqrt { 2 \cdot N_{coins} \cdot S_{block} \over K}
\end{equation}

that is for about 58 Gb for Bitcoin statistics and $K=10^{-8}$ ($BTC / (Byte \cdot Block)$). Taking into account common idea, that \state{} should be kept in memory, 58 Gb is quite big \state{} size, however modern RAM discs allows to keep it. Note also, that it is upper-bound of \state{} size calculated from non-realistic assumption that all available supply will be paid for space-time fee.

We may estimate expected \state{} size from assumption of fixed mining reward, namely that total miner block reward $M_{block}$ will be taken from space-time fee.

\begin{equation}
\label{eq:statesizeexp}
S \cdot K = M_{block}
\end{equation}

which leads to 1.3 Gb \state{} for $K=10^{-8}$ ($BTC / (Byte \cdot Block)$) which is close to current Bitcoins 1.6 Gb.

Thus \esse{} model allows to control \state{} with $K$ parameter, allowing to estimate expected \state{} size and it's upper bound. Reasonable $K$ value leads to 1.3 Gb of expected \state{} size and 58 Gb of it's upper bound, preventing DoS attacks like \cite{bitcoin2015flood} and ensuring that there is no way to increase it's size to exceed existing RAM drives.

\subsection{Subsidized space-time}

It is usual to pay for space-time multiplication for database leasing and thus \esse{} model is natural for blockchain-as-database model. On the other hand, in blockchain usage for currency it may be natural to allow users to keep some data for free in blockchain. In this section we are going to extend \esse{} model, subsidizing pre-defined by network space-time $S_s$ (which may also be defined by miners voting). For example, it may allow to keep simple money output for 10 years for free, subsidizing $S_s \approx 525600 (Blocks) \cdot 35 (Byte) \approx 18 (Mb \cdot Block)$. While 10 years is a quite big period for regular output, it is quite small amount of subsidized space-time for blockchain usage as a storage, e.g. will only allow to keep 127 Kb output for one date in \state{}.

Such subsidized fee may be calculated as

\begin{equation}
fee_{sub} = Max(0, K \cdot B \cdot L - S_s)
\end{equation}

and provides another way to control \esse{} economy with $S_s$ parameter. In particular it allows define $K$ and $S_s$ to archieve desired money flow and coin recirculation rates. As we have already noticed above $K$ parameter should be sufficiently different to archieve reasonable money flow and coin recirculation. It is possible to estimate $K$ and $S_s$ required for mean output lifetime $L_{mean}$ and mean coin recirculation periods $R_{mean}$ using assumptions from previous sections:

\begin{equation}
  \begin{array}{ccl}
   K \cdot B \cdot L_{max} - S_s & = & V_{output} \\
   K \cdot B \cdot L_{mean} - S_s & = & fee_{propagation}
  \end{array}
\end{equation}

Assuming $L_{mean}=1$ year and $L_{max}=10$ years and Bitcoin statistics, we may estimate values of $K$ and $S_s$:

\begin{equation}
  \begin{array}{ccl}
   K & = & {V_{output} - fee_{propagation} \over B \cdot (L_{max} - L_{mean})} \approx \quad 2*10^{-8} ({BTC / (Byte \cdot Block)}) \\
   S_s & = & {(V_{output} - fee_{propagation}) \cdot L_{mean} \over (L_{max} - L_{mean})} - fee_{propagation} \approx 0.04\quad(BTC)
  \end{array}
\end{equation}

which is equals to 2 ($Mb \cdot Block$) for free for each ouptut. This is exactly the increasing of upper bound for \state{} size because according to equation \ref{eq:statesizemax} subsidized space-time will just prolongate outputs lifetime for corresponding value. Morover according equation \ref{eq:statesizemax} expected \state{} size will remain the same because it is dictated by economical reasons only.

Thus, additional subsidized space-time parameter allows to use the same blockchain for both money and data applications. Subsidized value may be configured to be big enough for regular users, allowing them to keep their outputs for free for some time, but small enough for blockchain usage as database. It's impact to \state{} size is negligible, while it allows to increase $K$ value painlessly for regular users, but increasing lost coin recirculation rate.


\section{Related Work}

\dnote{transaction commission may be defined as $fee = Max(fee_{validation}, fee_{propagation}, fee_{space\_time})$}

\section{Further Work}

\dnote{Comparison with Gesell's money~(money with demurrage)}

\section{Conclusion}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\end{document}
