\documentclass[]{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\newtheorem{axiom}{Axiom}

\usepackage{systeme}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}


\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{blue}{Dima notes}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\esse}{\textit{Esse}}
\newcommand{\state}{\textit{State}}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\begin{document}

\title{On Space-Scarce Economy In Blockchain Systems}
\author{Dmitry Meshkov and Alexander Chepurnoy, IOHK Research}
\maketitle

\begin{abstract}
In this paper we study space-scarce economy in massively replicated open blockchain systems, like Bitcoin. In such systems, memory to hold a balance sheet needed to validate transactions becomes the most scarce resource eventually. Currently only technical solutions, not economic, are proposed in order to tackle this problem, which becomes harder for blockchain systems used to store data~(votes, certificates, logs etc.). We propose to add a new component to a transaction fee regime, fees based on how much additional space will be needed for new objects created in result of transaction processing, and fow how long they will live.    
\end{abstract}

\section{Introduction}

Bitcoin \cite{Nakamoto2008} has been introduced in 2008 by S. Nakamoto as a purely peer-to-peer version of electronic cash with a ledger written into blockchain data structure maintained by the whole network. Security of the scheme is relied on miners. If majority of miners are honest Bitcoin meets security goals as formal analysis~\cite{Garay2015} shows. For the work done a miner is claiming a reward in form of bitcoins created out of thin air in a newly created block according to predefined and hard-coded token emission schedule. 


  %A cryptocurrency should satisfy at least 2 properties assuming an honest majority and arbitrary adversarial behavior~\cite{Garay2015}. \textit{Persistence} guarantees that once a transaction goes more than $k$ blocks "deep" into the blockchain of one honest player, then it will be included in every honest player's blockchain with overwhelming probability, and it will be assigned a permanent position in the ledger. \textit{Liveness} guarantees that all transactions originating from honest participants will eventually end up at a depth more than $k$ blocks in an honest player's blockchain, and hence the adversary cannot perform a selective denial of service attack against honest account holders.

  %Bitcoin holds the \textit{liveness} property when honest miners are expected to be altruistic and so add transactions to blocks even if it is not profitable for them. 


An user pay fees to miners to have his transactions included into the blockchain. Fees are useful for existing cryptocurrency economy for several reasons:

\begin{enumerate}
  \item{Incentivizing a miner's activity. } A rational Bitcoin miner does not include all the valid transactions into blocks as, due to the increased chances of orphaning a block, the cost of adding transactions to the could not be ignored~\cite{rizun2015transaction, andresen2013}. As shown in \cite{rizun2015transaction}, even in absence of block size limit, Bitcoin fee market is healthy and the miners surplus is maximized at a finite quantity of block space, and thus the miner is incentivized to produce a block of a limited size. This means that only subset of transactions providing enough value to a miner will be included in a block. A paper~\cite{rizun2015transaction} provides a procedure to calculate transaction fee based on block propagation time, i.e. miners network resources utilization. 

  %We argue, that this is not the only component of the transaction fee, because a miner also utilizes other resources, and this fact should be taken into account.

  \item{Limit resources usage and spam. } Besides of network utilization, transaction processing requires miner to spend some computational resources. For most of the cryptocurrencies, transactional language is limited \cite{script}, so number of CPU cycles needed to process a transaction is bounded, and corresponding costs are not directly considered. In contrast, in cryptocurrencies supporting  smart contract languages, such as~\cite{seijas2016scripting, tezosScript, solidity}, transaction processing may require a lot of computations and computational costs are included to transaction fees there. This cost is specific to concrete transactional language and is out of scope of this paper.
\end{enumerate}

A transaction in Bitcoin spends outputs from previous transactions and creates new ones. A notable and the only exception is a coinbase transaction of a block which creates fixed amount of money out of thin air and also claims transaction fees without claiming any outputs~(a fee for an ordinary transaction is sum of claimed outputs values minus sum of created outputs values). A node is checking a transaction in Bitcoin by using a set of unspent outputs. In other cryptocurrencies a representation of a \textit{state} needed to validate an arbitrary transaction could be different~(for example, in Ethereum~\cite{ethyp} such a structure is called the \textit{world state} and is a part of the protocol).  For fast validation, the state~(or most accessed part of it) should reside in random-access memory. Once it becomes big enough to fit into RAM an attacker can perform denial-of-service attacks against cryptocurrency nodes. For example, during attacks on Ethereum in Autumn, 2016, an attacker added about 18 million accounts to the state~(which size was less than 1 million accounts before the attack) and then performed succesful denial-of-service attacks against the network. Similarly, in 2013 a denial-of-service attack against output storage residing in a secondary storage~(HDD or SSD) was discovered in Bitcoin. 


The main purpose of this paper is to consider a new mandatory component for a transaction fee scheme in regards with increasing the state. In all known cryptocurrencies of today, a state element once created lives forever and for free. This leads to continuously increasing state~(we refer to Bitcoin UTXO set size as to an example~\cite{utxoChart}). Moreover, state may grow fast during spam attack, for example, 15M additional outputs where introduced to Bitcoins UTXO during spam attacks in July 2015~\cite{bitcoin2015flood} and most of these outputs are not spent yet. The paper~\cite{} proposes a solution for non-mining nodes where only miners hold the full state~(assuming they can invest money in sufficiently big RAM storages) while other full-nodes are checking proofs of state transformation generated by miners, and a size of a proof (in average and also in worst case) is about $log(l_S)$ in regards with state $l_S$. Nevertheless, big state could lead to centralization of mining or SPV mining~\cite{spvMining}, and both concerns should be addressed. 
Also, there is an increasing demand to use a blockchain as a data storage, and storing permanently objects in the blockchain without a cleaning procedure is not a viable option. To prevent unreasonable state growing the new fee component should depend on space needed to store the state released by a transaction and space consumed by it, also considering expected time to live for state elements touched by the transaction. Later in this paper we will refer to the component as to a \textit{space-time fee}.

We propose a model where users should pay fee for both the state increasement and time new bytes will live in massively replicated storage of blockchain nodes~(the modes is usual for cloud storage services where users pay for gigabyte of data per month). Such an approach prevents putting any data to the storage forever. Also miners can control their storage requirements by changing a fee factor. 

The limited lifetime of a state element also leads to lost coins being taken back into circulation~(by miners). Another interesting effect is that the proposed fee regime is promoting money circulation in the blockchain economy.

Summarizing, we study an economy where memory of a massively-replicated system node is the most scarce resource. Thus we call such an economy a \textit{space-scarce economy}.  

The paper is organized as follows. A design of our model is described in Section~\ref{sec:model}. The model is analyzed in section~\ref{sec:analysis}.  \knote{finish}

\knote{note that we're talking about minimal fees}

\section{The Model}
\label{sec:model}

In our model transaction fee $f$ consists of 3 parts: \textit{validation cost} $f_v$, \textit{propagation cost} $f_p$ and \textit{state space-time difference cost} $f_s$ and is non-negative value:

\begin{equation}
f = f_v + f_p + f_s , f \ge 0
\end{equation}

Validation and propagation costs are strictly non-negative and assumed to be independent from the space-time fee. We assume that space-time fee impact to total fee $f$ may range from negligible to dominant. It is possible for $f_s$ to be negative since transaction may both increase and decrease state size. It depends on size of outputs to be marked as spent, newly created outputs and their time to live. Thus a transaction is freeing some space-time \textit{$T_{cleared}$} and claiming space-time \textit{$T_{filled}$}. Resulting space-time fee can be calculated as follows:
\begin{equation}
f_s = K \cdot (T_{filled} - T_{cleared})
\end{equation}

where \textit{K} is a space-time price in the fee tokens. We assume that miners can change this price via mechanism like ``gas'' in Ethereum~(based on hardware price for miners and token exchange rate) and thus control cost of blockchain support.

We further assume that outputs are protected by logical propositions and consider three options for the fee to be charged. Concretely, \textit{prepaid outputs} are defined in the Section~\ref{sec-prepaid}, \textit{postpaid outputs} are described in the Section~\ref{sec-postpaid} and \textit{scheduled payments} are proposed in the Section~\ref{sec-scheduled}.

\subsection{Prepaid Outputs}
\label{sec-prepaid}

First option we are going to analyze is prepaid outputs. In it each output of a size \textit{B} in a state is prepaid until explicitly known period of time $L_{max}$. After $L_{max}$ anyone~(presumably miner generated first block after that) is able to spend the overdue output. Thus a spending script for any output must be a combination of regular spending script and loan period $L_{max}$:

\begin{equation}
(Height > self.height + L_{max}) \lor (regular\_script)
\end{equation}

where \textit{Height} is current blockchain height and \textit{regular\_script} is user-defined spending script for the output. This form of a script is a part of consensus and mandatory space-time fee is to be paid by a transaction ccreating the output:

\begin{equation}
f_{s-prepaid} = K \cdot (\sum_i{(B_i \cdot (L_{max\_i} - Height))} - \sum_j{(B_j \cdot (L_{max\_j} - Height)}))
\end{equation}

\subsection{Postpaid Outputs}
\label{sec-postpaid}


In the second model, user should pay fee for consumed space-time when he spends an output. When output is spent its lifetime is known so resulting transaction fee can be calculated:

\begin{equation}
f_{s-postpaid} = \sum_i{(K_i \cdot B_i \cdot (H_{spent\_i} - H_{creation\_i}))}
\end{equation}

where $H_{creation\_i}$ and $H_{spent\_i}$ are heights where i-th output was created and spent respectively. Note that each output has its own space-time price \textit{$K_i$} which is the \textit{K} value at the time of the output creation. Here we can note, that if output value is \textit{V}, then height \textit{$H_{max}$} exists, where all the output value will be taken by space-time fee.

\begin{equation}
H_{max} = {H_{creation} + {V \over {K \cdot B}}}
\end{equation}

After that anyone should be able to spend this output, sending all it's value to transaction fee and spending script will looks like

\begin{equation}
(Height > self.height + H_{max}) \lor (regular\_script)
\end{equation}

\subsection{Scheduled Payments}
\label{sec-scheduled}

The last model we introduce is a combination of the prepaid and postpaid models. Like in the postpaid model, an user pays for an output when he spends it in a transaction, but he is also enforced to move his coins before a known time $H_{creation} + H_{demurrage}$. If the user do not do this, anyone can create a transaction with this output, returning them to owner without space-time fee ${K \cdot B \cdot H_{demurrage}}$. The spending script for the output would be like

\begin{align}
\begin{split}
&(regular\_script) \lor \\
&(Height > (self.height + H_s) \land \\  
&\qquad has\_output(value = self.value - K \cdot B \cdot H_s, script = self.script))
\end{split}
\end{align}



In this model $H_{demurrage}$ is another protocol parameter, that may be fixed by protocol design or changed via miners voting like \textit{K}.

\section{Analysis of The Model}
\label{sec:analysis}

In this section we provide analysis of the model. Besides of its main goal to control state size, it provides additional benefits as side-effects, that can be used in cryptocurrency design. Our further analysis will be based on the following stats from current Bitcoin network:

\begin{itemize}
  \item Number of unspent transaction outputs: $N_{UTXO} \approx 45,000,000$
  \item Number of coins in circulation: $N_{coins} \approx 16,000,000$ BTC
  \item Mean number of coins in an output: $V_{mean} \approx 0.35$ BTC
  \item Simple payment transaction fee: $f_{p} \approx 0.0002$ BTC
  \item Mean output size: $B_{mean} \approx 36$ Bytes
  \item Per cent of coins, moved in every block: $M_{flow} \approx 0.013$ \%
  \item Time interval between blocks: $T_{block} \approx 10$ minutes
  \item Transaction fees per block: $M_{pg} \approx 1$ BTC
  \item Fixed block reward: $R_{f} \approx 12.5$ BTC
\end{itemize}

\subsection{Lost coins recirculation}
\label{sec:re}

The need of recirculating lost coins was widely discussed in cryptocurrencies \cite{gjermundrod2014recirculating, gjermundrod2016going} in order to combat deflation that will inevitably occur in cryptocurrencies with the fixed amount of coins to be circulated. Coins declared supply is known by cryptocurrency design, but available supply is unknown due to lost coins, locked in outputs that will never be spent \cite{ron2013quantitative}. On the other hand deflation is a real problem in the traditional monetary system, but it is still open question, whether it will also be a problem in the Bitcoin economy \cite{bitcoinDeflationarySpiral, barber2012bitter}.

While negative impact of deflation to cryptocurrencies is not proven, most of researchers agree in non-negative impact of lost coins recirculating. \esse{} model provide lost coins recirculation mechanism by design, while it's properties vary from model implementation and parameters. In this section we are going to estimate lost coins recirculation dependency from chosen model and it's parameters.

Fee for keeping output of size \textit{B} is the \state{} for \textit{L} blocks is ${K \cdot B \cdot L}$. In \textit{Postpaid} and \textit{Demurrage balance} models space-time fee is taken from output value itself, so when keys for output with \textit{$V_{output}$} coins are lost, they will return to economy after \textit{$L_{max}$} blocks, where

\begin{equation}
{L_{max} = {V_{output} \over K \cdot B}}
\end{equation}

Maximum lifetime of a concrete outputs depends on miner-controlled \textit{K} parameter and user-defined output size and value. As in previous section we will estimate this dependency based on Bitcoin stats:

\begin{equation}
{L_{max} \approx {1 \over 100 \cdot K}}
\end{equation}

Based on this equation, it is possible to chose \textit{K} keeping in mind desired maximum output lifetime. Desiring 100 years period of coins fully recirculation, \textit{K} parameter should equals $2 \cdot 10^{-9}$ that is close to $10^{-9}$ from previous section. Regarding lost coins recirculation, significant difference between \textit{Postpaid} and \textit{Demurrage balance} is that in \textit{Postpaid} all coins will return to economy all at once after some quite big $L_{max}$ period, while in \textit{Demurrage balance} they will return to economy by small portions during this period. This makes \textit{Demurrage balance} preferable to \textit{Postpaid}, because lost coins from big enough outputs in \textit{Postpaid} will not return to the circulation in foreseeable future. Anyway in a log-term equilibrium conditions coins recirculation rate of both models will be calculated as

\begin{equation}
R_{postpaid} = R_{demurrage} = {N_{lost} \cdot V_{output} \over L_{max}} = {N_{lost} \cdot K \cdot B}
\end{equation}

where $N_{lost}$ is the number of outputs with lost keys. Assuming current Bitcoins statistics, $N_{lost}\approx10^6$ and $K = 10^{-9}$ we can estimate, that $\approx0.036$ BTC will be released from abandoned outputs every block.

In \textit{Prepaid} model user define $L_{max}$ by himself when he creates output and number of released coins after $L_{max}$ is equals to output value $V_{output}$ rater than much smaller space-time fee $fee_{space\_time}$. Note here, that $L_{max}$ do not directly depends on \textit{K} and coins recirculation rate will only depend on $V_{output}$, user-defined $L_{max}$ and number of lost outputs $N_{lost}$:

\begin{equation}
R_{prepaid} = {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

Let's assume user-defined coin recirculation period $L_{max}\approx10$ years and $K\approx10^{-9}$ from previous section, we can estimate difference between prepaid and postpaid models:

\begin{equation}
{R_{prepaid} \over R_{postpaid}} = { V_{output}  \over  K \cdot B \cdot L_{max}} \approx 20
\end{equation}

Thus \esse{} model by design provide a way to return lost coins to circulation, preventing deflation risks. \textit{Postpaid} model has a disadvantage, that lost coins will be returned to circulation in a far future, in \textit{Prepaid} model coin recirculation rate is much higher than in other models and \textit{Demurrage balance} model is a smoother way of coin recirculation.

\subsection{Miner rewards}
\label{minerrew}
Mining reward is very important for cryptocurrency economy - in original paper \cite{Nakamoto2008} it's assumed, that miners are incentivized to fair behaviour, while recent researches showed, that it is not always correct \cite{carlsten2016instability, eyal2014}. In addition to usual propagation fee, \esse{} provides two new sources for miner income: a space-time fee and a coin recirculation reward.

\begin{equation}
M_{reward} = M_{propagation} + M_{space-time} + M_{recirculation}
\end{equation}

In section \ref{sec:flow} we have noticed, that \esse{} users have an incentive to actively use their coins and propagation reward is correlated with space-time reward:

\begin{equation}
M_{propagation} = C \cdot M_{space-time} + M_{pg}
\end{equation}

where $C$ is non-negative constant. Space-time miner reward depends on \state{} size and space-time price $K$ only:

\begin{equation}
M_{space-time} = \sum_{i=1}^{N_{UTXO}} K_i \cdot B_i \approx K \cdot N_{UTXO} \cdot B
\end{equation}

Recirculation reward was calculated in previous section and depends on space-time fee model. However it can be generalized as with $K_{model}$ parameter, that is equals to 1 for \textit{Demurrage balance} and \textit{Postpaid} models, and $K_{model} \approx 20$ for \textit{Prepaid} model:

\begin{equation}
M_{recirculation} = {K_{model} \cdot  N_{lost} \cdot K \cdot B}
\end{equation}

Resulting miner reward:

\begin{equation}
\label{eq:reward}
M_{reward} \approx M_{pg} + (K \cdot B) \cdot ((1 + M) \cdot N_{UTXO} + K_{model} \cdot N_{lost})
\end{equation}

First part of this equation $M_{pg}$ is the reward of miner in existing fee models, the rest is the unique reward for \esse{} model.  In a sensible assumption $N_{UTXO} >> N_{lost}$ equation \ref{eq:reward} can be simplified to

\begin{equation}
M_{postpaid} \approx M_{pg} + K \cdot B \cdot N_{UTXO} \cdot (1 + M)
\end{equation}

that allows to estimate such $K$, when additional \esse{} reward will exceed common propagation reward $M_{pg}$:

\begin{equation}
M_{postpaid} = {M_{pg} \over B \cdot N_{UTXO} \cdot (1 + M)} \approx 10^{-9} ({BTC / (Byte \cdot Block)})
\end{equation}

that is naturally coincide to estimations from section \ref{eq:ltmean} while miner reward equals to user losses.

Remarkable that space-time reward does not depend on network throughput and can be easily predicted. Since it will be accrued to generator of block with concrete height, it may be considered as a constant block reward fixing problem of blockchain instability without block reward \cite{carlsten2016instability}. It's value may be controlled by $K$ parameter making mining more stable and thus network more secure.

\dnote{What is an output value when miner is interested in collecting it?}

\subsection{Cryptocurrency inflation}

As we have already noticed in section \ref{minerrew}, miners reward from space-time fee can be considered as static block reward. Extending this idea it is possible to get rid of coinbase transactions breaking usual transaction rule that sum of inputs should not be less then sum of outputs. To achieve this, all coins should be issued in genesis block in such a way, that every block one output will be released and miner will collect it's value according space-time fee model. Thereafter miner will collect reward in uniform way collecting abandoned outputs, whenever it was created in genesis or by cryptocurrency user.

After all coins issue, nothing changes from both miners and users point of view: part of users money move every block to miner. Note, that it is isomorphic to inflation in existing cryptocurrencies, when users accumulations remain the same, but total supply increases via static miner reward.

\subsection{State size}

Finally, we are going to analyze direct assignment of \esse{} model - to control \state{} size. Upper bound of \state{} size is $S$ may be easily calculated from assumption, that all available supply will be paid for space-time fee for one huge output to keep it in state for 1 block. However usually block size is limited by $S_{block}$ parameter and thus maximum output size is $B = S_{block}$. As soon as each block space-time fee $K \cdot B$ should be paid for all previously created outputs, maximum possible number of such outputs $O_{max}$ may be calculated from equation:

\begin{equation}
N_{coins} = \sum_i^{O_{max}}{K \cdot S_{block} \cdot i} = K \cdot S_{block} \cdot ( O_{max}^2 + O_{max}) / 2 \approx K \cdot S_{block} \cdot O_{max}^2 / 2
\end{equation}

assuming that number of unspent outputs is big enough. Resulting state size

\begin{equation}
\label{eq:statesizemax}
S = S_{block} \cdot O_{max} = \sqrt { 2 \cdot N_{coins} \cdot S_{block} \over K}
\end{equation}

that is for about 183 Gb for Bitcoin statistics and $K=10^{-9}$ ($BTC / (Byte \cdot Block)$). Taking into account common idea, that \state{} should be kept in memory, 183 is quite big \state{} size, however modern RAM discs allows to keep it. Note also, that it is upper-bound of \state{} size calculated from non-realistic assumption that all available supply will be paid for space-time fee.

We may estimate expected \state{} size from assumption of fixed mining reward, namely that total miner block reward $M_{block}$ will be taken from space-time fee.

\begin{equation}
\label{eq:statesizeexp}
S \cdot K = M_{block}
\end{equation}

which leads to 13 Gb \state{} for $K=10^{-9}$ ($BTC / (Byte \cdot Block)$) which is small enough to be processed on common hardware.

Thus \esse{} model allows to control \state{} with $K$ parameter, allowing to estimate expected \state{} size and it's upper bound. Reasonable $K$ value leads to 13 Gb of expected \state{} size and 183 Gb of it's upper bound, preventing DoS attacks like \cite{bitcoin2015flood} and ensuring that there is no way to increase it's size to exceed existing RAM drives.

\subsection{Money flow}
\label{sec:flow}

From users point of view, the longer you keep some output, the bigger space-time fee you pay. Thus the proposed fee regime provides an incentive to move coins stimulating economic activity. In all the fee models introduced in Section~\ref{sec:model}, user pays ${K \cdot B}$ coins every block for keeping his output in the state. If he uses blockchain with output size \textit{B} is relatively small and do not depend on output value.

To estimate money flow let's assume, that user will move his money when space-time fee will start dominate over other transactional costs \dnote{why?}. Thus we can estimate expected mean output lifetime as

\begin{equation}
\label{eq:ltmean}
L_{mean}={fee_{propagation} \over K \cdot B}
\end{equation}

Since there are $N_{UTXO}$ in a system and each of them contains $V_{output}$ coins, we can estimate number of transactions per block incentivized by \esse{} model:

\begin{equation}
N_{transactions} \approx {N_{UTXO} \over L_{mean}} = {N_{UTXO} \cdot K \cdot B \over fee_{propagation}}
\end{equation}

and share of coins moved in a block:

\begin{equation}
M_{flow} \approx { N_{transactions} \cdot V_{output} \over N_{coins}} = {K \cdot B \over fee_{propagation}}
\end{equation}

Thus, money flow may be controlled with \textit{K} parameter. This formula provide a way to estimate \textit{K} based on current Bitcoin statistics:

\begin{equation}
K={M_{flow} \cdot fee_{propagation} \over B} \approx {10^{-9}} ({BTC / (Byte \cdot Block)})
\end{equation}

For regular outputs of 36 Bytes space-time fee part will exceed propagation fee after 5555 blocks or 38 days. This means, that for active users, who spend their money more often than once a month, space-time fee will be negligible relative to propagation fee.

From money flow analysis we can find out how to use \esse{} model to control cryptocurrency money flow, changing space-time price and encourage active economy participants. Another money flow analysis result is the dependency between $L$ and $K$ \ref{eq:ltmean} that can particularly by used in the \textit{Demurrage balance} model to reduce number of model parameters.

\section{Subsidized space-time}

It is usual to pay for space-time multiplication for database leasing and thus \esse{} model is natural for blockchain-as-database model. On the other hand, in blockchain usage for currency it may be natural to allow users to keep some data for free in blockchain. In this section we are going to extend \esse{} model, subsidizing pre-defined by network space-time $S_s$ (which may also be defined by miners voting). For example, it may allow to keep simple money output for 10 years for free, subsidizing $S_s \approx 525600 (Blocks) \cdot 35 (Byte) \approx 18 (Mb \cdot Block)$. While 10 years is a quite big period for regular output, it is quite small amount of subsidized space-time for blockchain usage as a storage, e.g. will only allow to keep 127 Kb output for one day in \state{}.

Such subsidized fee may be calculated as

\begin{equation}
fee_{sub} = Max(0, K \cdot B \cdot L - S_s)
\end{equation}

and provides another way to control \esse{} economy with $S_s$ parameter. In particular it allows define $K$ and $S_s$ to achieve desired money flow and coin recirculation rates. It is possible to estimate $K$ and $S_s$ required for mean output lifetime $L_{mean}$ and mean coin recirculation periods $R_{mean}$ using assumptions from previous section:

\begin{equation}
  \begin{array}{ccl}
   K \cdot B \cdot L_{max} - S_s & = & V_{output} \\
   K \cdot B \cdot L_{mean} - S_s & = & fee_{propagation}
  \end{array}
\end{equation}

Assuming $L_{mean}=1$ year and $L_{max}=10$ years and Bitcoin statistics, we may estimate values of $K$ and $S_s$:

\begin{equation}
  \begin{array}{ccl}
   K & = & {V_{output} - fee_{propagation} \over B \cdot (L_{max} - L_{mean})} \approx \quad 2*10^{-8} ({BTC / (Byte \cdot Block)}) \\
   S_s & = & {(V_{output} - fee_{propagation}) \cdot L_{mean} \over (L_{max} - L_{mean})} - fee_{propagation} \approx 0.04\quad(BTC)
  \end{array}
\end{equation}

which is equals to 2 ($Mb \cdot Block$) for free for each ouptut. This is exactly the increasing of upper bound for \state{} size because according to equation \ref{eq:statesizemax} subsidized space-time will just prolongate outputs lifetime for corresponding value. Moreover according equation \ref{eq:statesizemax} expected \state{} size will remain the same because it is dictated by economical reasons only.

Thus, additional subsidized space-time parameter allows to use the same blockchain for both money and data applications. Subsidized value may be configured to be big enough for regular users, allowing them to keep their outputs for free for some time, but small enough for blockchain usage as database. It's impact to \state{} size is negligible, while it allows to increase $K$ value painlessly for regular users, but increasing lost coin recirculation rate.


\section{Related Work}

\section{Further Work}

\dnote{transaction commission may be defined as $fee = Max(fee_{validation}, fee_{propagation}, fee_{space\_time})$}

\dnote{Comparison with Gesell's money~(money with demurrage)}

\section{Conclusion}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\end{document}
