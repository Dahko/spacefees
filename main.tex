\documentclass[]{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}


\newtheorem{axiom}{Axiom}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}


\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{blue}{Dima notes}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\esse}{Esse}
\newcommand{\state}{\textit{State}}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\begin{document}

\title{\esse: Space-scarce economy model for cryptocurrencies}
\author{Dmitry Meshkov and Alexander Chepurnoy, IOHK Research}
\maketitle

\section{Introduction}

Bitcoin \cite{nakamoto2008bitcoin} has been invented in 2008 by Nakamoto as a purely peer-to-peer version of electronic cash. \dnote{more words about bitcoin as an economy}

Any cryptocurrency should satisfy at least 2 properties needed by the ledger assuming an honest majority and arbitrary adversarial behavior \cite{Garay2015}. First of them, \textit{Persistence} states that once a transaction goes more than k blocks "deep" into the blockchain of one honest player, then it will be included in every honest player's blockchain with overwhelming probability, and it will be assigned a permanent position in the ledger. Another basic property \textit{Liveness} says that all transactions originating from honest account holders will eventually end up at a depth more than k blocks in an honest player's blockchain, and hence the adversary cannot perform a selective denial of service attack against honest account holders.

Bitcoin satisfies \textit{Liveness} property when honest miners are expected to be altruistic and adds transactions to blocks even if it's not profitable for them. On the other hand, rational miner won't include all valid transactions into blocks, because due to the increased chances of orphaning a block, the cost of adding transactions to block is not zero\cite{rizun2015transaction, andresen2013}. As it was shown in \cite{rizun2015transaction}, even in absence of block size limit, Bitcoin fee market is healthy and the miners surplus is maximized at a finite quantity of block space, and thus the miner is incentivized to produce a finite block. This means, that only subset of transactions, providing enough fee for miners will be included in blocks and both miners and users needs explicit rules how to calculate transaction fee in current environment. \cite{rizun2015transaction} provide a way, how to calculate transaction fee regarding block propagation time, i.e. miners network resources utilization. We argue, that this is not the only component of the transaction fee, because miner also utilize other his resources that should be considered.

Besides of network utilization, transaction processing requires computations from miner. For most of cryptocurrencies transactional language is limited \cite{script}, their validation is very fast and this cost may not be considered, but for cryptocurencies with rich transaction language \dnote{more links e.g. for sigma-state} this cost is not negligible. In so-called smart contract languages \cite{seijas2016scripting, tezosScript, solidity} transaction processing may require a lot of computations and computational costs are included to transaction fees there. This cost is specific to concrete transactional language and is out of scope of this paper.

The main purpose of this paper is to consider third component of the transaction fee, that is related with increasing local miners \state. In all known cryptocurrencies, when a miner accepts a transaction that increases it's current \state, he takes on a liability equal to the present value of the cost of storing those new outputs indefinitely far into the future. This in not healthy situation that is leading to continuously increasing state \state \cite{utxoChart}, e.g. number of unspent transaction outputs increases by 12000 every year in Bitcoins. Moreover state size may increase very fast during spam attack, e.g. 15000 additional outputs where added to Bitcoins UTXO during spam attacks in July 2015 \cite{bitcoin2015flood} and most of this outputs are not spent yet. Thus miner's \state may significantly increases during attacks and this attacks are free for adversary, meaning that transaction fee for increasing \state size is 0. Note, that for efficient block processing, \state should be kept in memory, otherwise attacks where miner generate block that will be validated for a long time by other miners come into being \dnote{link to ethereum DoS, + others?}. Big \state size leads to centralization, where hardware requirements are too big for common users, and to SPV mining, where miners are tring to generate a new block without transaction validation of previous one. In July 2015 this resulted in invalid chain of 6 blocks\cite{spvMining}, that is enough to perform double-spend attack in most of Bitcoin applications.

We propose a model, where users should pay fee for multiplication of the time output data should be kept in \state to it's size. This is very usual for most of storage services, where users pay for gigabyte of data per month. \dnote{paper structure}

\dnote{write somewhere about lost coins and deflation}

\subsection{Motivation}

Problems
\begin{itemize}
  \item It's possible to put some data to be kept forever, e.g. create an output nobody can spend. UTXO is ever growing~(https://blockchain.info/charts/utxo-count).
  \item Without emission it's about deflation due to lost keys etc, so it is profitable to keep your money in a deflationary economy
%  \item Being quite simple by design, \esse provides plenty of outstanding results. With it, miners are getting a \textbf{new way to be rewarded} by collecting garbage. With this reward, fixed block reward is not required any more for network stability \dnote{link to instability of Bitcoin without block reward} and allows \ergo to stop emission quite soon. Moreover with this economy miners will have \textbf{lower-bound for their rewards}, providing more stable mining and, therefore, secure network. Another \esse feature, important for miners, is that it provides fee \textbf{mechanism to control state size}, preventing network centralization on a few amount of very powerful computers. From economy point of view, \esse provide an incentive to move your coins, \textbf{preventing economy stagnation}, and a way to return lost coins back to economy, \textbf{prevenring deflation}.
\end{itemize}


\section{The Model}

State-centric design

$fee = max(fee_{validation\_cost} + fee_{transaction\_size} + fee_{space\_time\_difference}, 0)$

$fee_{space\_time\_difference} = K \cdot (\sum{(new\_output\_size \cdot lifetime - S_s)} - \sum{(old\_output\_size \cdot remaining\_lifetime - S_s)})$

$S_s$ is a subsidified space-time amount (e.g. 500 byte-years which is about free storage for 10 years for a standard 50 bytes output)

Space-time is a new concept, where object to be put into state for some time with a fee to be paid based on both parameters~(space and time). 


%Associated value must be not less than $K \cdot S_s$ 


\assumption{For simplicity, we can assume $fee_{transaction\_size} = T \cdot (constant\_factor + \sum{new\_output\_size})$}, where $T$ is a price for 1 byte broadcasting \& mempool storage costs.

\assumption{We assume all the money are issued, so total system balance is constant. We can emulate Bitcoin emission with outputs being pre-created in genesis and being releasing 1 output per block.}


\section{Analysis of The Model}

TODO:

\begin{itemize}

\item{What is an output value when miner is interested in collecting it?}

\item{Max and expected state size}

\item{Minimal money flow}

\item{Expected minimum miner rewards with no coins ever lost in some UTXO model(constant? growing?)}

\item{All the money can be issued in genesis, with release 1 output per block}

\item{Comparison with Gesell's money~(money with demurrage)}

\item{Miners are getting a new kind of profit}

\end{itemize}


\section{Related Work}

\section{Conclusion}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\end{document}	
