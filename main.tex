\documentclass[]{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\newtheorem{axiom}{Axiom}

\usepackage{systeme}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}


\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{blue}{Dima notes}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\esse}{\textit{SSE}}
\newcommand{\state}{\textit{State}}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\begin{document}

\title{On Space-Scarce Economy\\ In Blockchain Systems}
\author{Dmitry Meshkov and Alexander Chepurnoy, IOHK Research}
\maketitle

\begin{abstract}
In this paper we study space-scarce economy in massively replicated open blockchain systems, like Bitcoin. In such systems, memory to hold a balance sheet needed to validate transactions becomes the most scarce resource eventually. Currently only technical solutions, not economic, are proposed in order to tackle this problem, which becomes harder for blockchain systems used to store data~(votes, certificates, logs etc.). We propose to add a new component to a transaction fee regime, fees based on how much additional space will be needed for new objects created in result of transaction processing, and fow how long they will live.    
\end{abstract}

\section{Introduction}

Bitcoin \cite{Nakamoto2008} has been introduced in 2008 by S. Nakamoto as a purely peer-to-peer version of electronic cash with a ledger written into blockchain data structure maintained by the whole network. Security of the scheme is relied on miners. If majority of miners are honest Bitcoin meets security goals as formal analysis~\cite{Garay2015} shows. For the work done a miner is claiming a reward in form of bitcoins created out of thin air in a newly created block according to predefined and hard-coded token emission schedule. 


  %A cryptocurrency should satisfy at least 2 properties assuming an honest majority and arbitrary adversarial behavior~\cite{Garay2015}. \textit{Persistence} guarantees that once a transaction goes more than $k$ blocks "deep" into the blockchain of one honest player, then it will be included in every honest player's blockchain with overwhelming probability, and it will be assigned a permanent position in the ledger. \textit{Liveness} guarantees that all transactions originating from honest participants will eventually end up at a depth more than $k$ blocks in an honest player's blockchain, and hence the adversary cannot perform a selective denial of service attack against honest account holders.

  %Bitcoin holds the \textit{liveness} property when honest miners are expected to be altruistic and so add transactions to blocks even if it is not profitable for them. 


An user pay fees to miners to have his transactions included into the blockchain. Fees are useful for an existing cryptocurrency economy for two reasons:

\begin{enumerate}
  \item{Incentivizing a miner's activity. } A rational Bitcoin miner does not include all the valid transactions into blocks as, due to the increased chances of orphaning a block, the cost of adding transactions to the could not be ignored~\cite{rizun2015transaction, andresen2013}. As shown in \cite{rizun2015transaction}, even in absence of block size limit, Bitcoin fee market is healthy and the miners surplus is maximized at a finite quantity of block space, and thus the miner is incentivized to produce a block of a limited size. This means that only subset of transactions providing enough value to a miner will be included in a block. A paper~\cite{rizun2015transaction} provides a procedure to calculate transaction fee based on block propagation time, i.e. miners network resources utilization. 

  %We argue, that this is not the only component of the transaction fee, because a miner also utilizes other resources, and this fact should be taken into account.

  \item{Limit resources usage and spam. } Besides of network utilization, transaction processing requires miner to spend some computational resources. For most of the cryptocurrencies, transactional language is limited \cite{script}, so number of CPU cycles needed to process a transaction is bounded, and corresponding costs are not directly considered. In contrast, in cryptocurrencies supporting  smart contract languages, such as~\cite{seijas2016scripting, tezosScript, solidity}, transaction processing may require a lot of computations and computational costs are included to transaction fees there. This cost is specific to concrete transactional language and is out of scope of this paper.
\end{enumerate}

A transaction in Bitcoin spends outputs from previous transactions and creates new ones. A notable and the only exception is a coinbase transaction of a block which creates fixed amount of money out of thin air and also claims transaction fees without claiming any outputs~(a fee for an ordinary transaction is sum of claimed outputs values minus sum of created outputs values). A node is checking a transaction in Bitcoin by using a set of unspent outputs. In other cryptocurrencies a representation of a \textit{state} needed to validate an arbitrary transaction could be different~(for example, in Ethereum~\cite{ethyp} such a structure is called the \textit{world state} and is a part of the protocol).  For fast validation, the state~(or most accessed part of it) should reside in random-access memory. Once it becomes big enough to fit into RAM an attacker can perform denial-of-service attacks against cryptocurrency nodes. For example, during attacks on Ethereum in Autumn, 2016, an attacker added about 18 million accounts to the state~(which size was less than 1 million accounts before the attack) and then performed succesful denial-of-service attacks against the network. Similarly, in 2013 a denial-of-service attack against output storage residing in a secondary storage~(HDD or SSD) was discovered in Bitcoin. 


The main purpose of this paper is to consider a new mandatory component for a transaction fee scheme in regards with increasing the state. In all known cryptocurrencies of today, a state element once created lives forever and for free. This leads to continuously increasing state~(we refer to Bitcoin UTXO set size as to an example~\cite{utxoChart}). Moreover, state may grow fast during spam attack, for example, 15M additional outputs where introduced to Bitcoins UTXO during spam attacks in July 2015~\cite{bitcoin2015flood} and most of these outputs are not spent yet. The paper~\cite{reyzin2016improving}\dnote{was it assumed?} proposes a solution for non-mining nodes where only miners hold the full state~(assuming they can invest money in sufficiently big RAM storages) while other full-nodes are checking proofs of state transformation generated by miners, and a size of a proof (in average and also in worst case) is about $log(l_S)$ in regards with state $l_S$. Nevertheless, big state could lead to centralization of mining or SPV mining~\cite{spvMining}, and both concerns should be addressed.
Also, there is an increasing demand to use a blockchain as a data storage, and storing permanently objects in the state without a cleaning procedure is not a viable option. To prevent unreasonable state growing the new fee component should depend on space needed to store the state released by a transaction and space consumed by it, also considering expected time to live for state elements touched by the transaction. Later in this paper we will refer to the component as to a \textit{space-time fee}.

We propose a model where users should pay fee for both the state increasement and time new bytes will live in massively replicated storage of blockchain nodes~(this model is usual for cloud storage services where users pay for gigabyte of data per month). Such an approach prevents putting any data to the storage forever. Also miners can control their storage requirements by changing a fee factor. 

The limited lifetime of a state element also leads to lost coins being taken back into circulation~(by miners). Another interesting effect is that the proposed fee regime is promoting money circulation in the blockchain economy.

Summarizing, we study an economy where memory of a massively-replicated system node is the most scarce resource. Thus we call such an economy a \textit{space-scarce economy}.  

The paper is organized as follows. A design of our model is described in Section~\ref{sec:model}. The model is analyzed in section~\ref{sec:analysis}.  \knote{finish}

\knote{note that we're talking about minimal fees}

\subsection{Assumptions}
\begin{itemize}
  \item{} We assume that all the fees for a block are going to a single miner like in Bitcoin at the moment. There are proposals to share the rewards for a block within a grou of miners~(for example, reward miners of some number of blocks before or after current one \cite{eyal2016bitcoin, kogias2016enhancing})\knote{links to Bitcoin-NG, ByzCoin}. The main difference is that in Bitcoin a miner can include his transactions into a block for free. In such systems analysis results would be different.
  \item{language} \knote{TODO: fill the description}
  \item{} We assume that a block is of a finite size but all the transactions a miner has at a given moment of time could be packed into it. 
\end{itemize}


\section{The Model}
\label{sec:model}

In our model transaction fee $f$ consists of 3 parts: \textit{validation cost} $f_v$, \textit{propagation cost} $f_p$ and \textit{state space-time difference cost} $f_s$ and is non-negative value:

\begin{equation}
f = f_v + f_p + f_s , f \ge 0
\end{equation}

Validation and propagation costs are strictly non-negative and assumed to be independent from the space-time fee. We assume that space-time fee impact to total fee $f$ may range from negligible to dominant. It is possible for $f_s$ to be negative since transaction may both increase and decrease state size. It depends on size of outputs to be marked as spent, newly created outputs and their time to live. Thus a transaction is freeing some space-time \textit{$T_{cleared}$} and claiming space-time \textit{$T_{filled}$}. Resulting space-time fee can be calculated as follows:
\begin{equation}
f_s = K \cdot (T_{filled} - T_{cleared})
\end{equation}

where \textit{K} is a space-time price in the fee tokens. We assume that miners can change this price via mechanism like ``gas'' in Ethereum~(based on hardware price for miners and token exchange rate) and thus control cost of blockchain support.

We further assume that outputs are protected by logical propositions and consider three options for the fee to be charged. Concretely, \textit{prepaid outputs} are defined in the Section~\ref{sec-prepaid}, \textit{postpaid outputs} are described in the Section~\ref{sec-postpaid} and \textit{scheduled payments} are proposed in the Section~\ref{sec-scheduled}.

\subsection{Prepaid Outputs}
\label{sec-prepaid}

First option we are going to analyze is prepaid outputs. In it each output of a size \textit{B} in a state is prepaid until explicitly known period of time $L_{max}$. After $L_{max}$ anyone~(presumably miner generated first block after that) is able to spend the overdue output. Thus a spending script for any output must be a combination of regular spending script and loan period $L_{max}$:

\begin{equation}
(Height > self.height + L_{max}) \lor (regular\_script)
\end{equation}

where \textit{Height} is current blockchain height and \textit{regular\_script} is user-defined spending script for the output\dnote{What is self.height?}. This form of a script is a part of consensus and mandatory space-time fee is to be paid by a transaction creating the output:

\begin{equation}
f_{s-prepaid} = K \cdot (\sum_i{(B_i \cdot (L_{max\_i} - Height))} - \sum_j{(B_j \cdot (L_{max\_j} - Height)}))
\end{equation}

After $L_{max}$ the output is spendable by anyone~(presumably, miner).

\subsection{Postpaid Outputs}
\label{sec-postpaid}


In the second model, user should pay fee for consumed space-time when he spends an output. When output is spent its lifetime is known so resulting transaction fee can be calculated:

\begin{equation}
f_{s-postpaid} = \sum_i{(K_i \cdot B_i \cdot (H_{spent\_i} - H_{creation\_i}))}
\end{equation}

where $H_{creation\_i}$ and $H_{spent\_i}$ are heights where i-th output was created and spent respectively. Note that each output has its own space-time price \textit{$K_i$} which is the \textit{K} value at the time of the output creation. Here we can note, that if output value is \textit{V}, then height \textit{$H_{max}$} exists, where all the output value will be taken by space-time fee.

\begin{equation}
H_{max} = {H_{creation} + {V \over {K \cdot B}}}
\end{equation}

After that anyone should be able to spend this output, sending the whole value to transaction fee and spending script will looks like

\begin{equation}
(Height > self.height + H_{max}) \lor (regular\_script)
\end{equation}

\subsection{Scheduled Payments}
\label{sec-scheduled}

The last model we introduce is a combination of the prepaid and postpaid models. Like in the postpaid model, an user pays for an output when he spends it in a transaction, but he is also enforced to move his coins before a known duration $D_{s}$ since output creation. If the user do not do this, anyone can create a transaction with this output, returning them to owner without space-time fee ${K \cdot B \cdot D_{s}}$. The spending script for the output would be like

\begin{align}
\begin{split}
&(regular\_script) \lor \\
&(Height > (self.height + D_s) \land \\  
&\qquad has\_output(value = self.value - K \cdot B \cdot D_s, script = self.script))
\end{split}
\end{align}

\dnote{With this script output is kept for free after $D_s$, if noone spent it.}

In this model $D_s$ is another protocol parameter, that may be fixed by protocol design or changed via miners voting like \textit{K}.

\section{Analysis of the Model}
\label{sec:analysis}

In this section we provide analysis of the model. We study how efficient is the proposal regarding the main goal to control state size. We get estimations for additional miners
rewards as well as lost coins recirculation. Throughout this section we use following values got from current state of the Bitcoin network:

\begin{itemize}
  \item number of unspent transaction outputs: $N_{utxo} \approx 45,000,000$
  \item number of coins in circulation: $N_{coins} \approx 16,000,000$ BTC
  \item mean value of an output: $V_{mean} \approx 0.35$ BTC
  \item simple payment transaction fee: $f_{p} \approx 0.0002$ BTC
  \item mean output size: $B_{mean} \approx 36$ Bytes
  \item share of coins moved in every block: $M_{flow} \approx 0.013$ \%
  \item time interval between blocks: $T_{block} \approx 10$ minutes
  \item transaction fees per block: $M_{pg} \approx 1$ BTC
  \item constant block reward: $R_{f} = 12.5$ BTC
  \item average number of outputs spent in a block $N_{moved} \approx 5,500$ 
\end{itemize}

We use numbers from the Bitcoin to calculate some typical cases as this is the most used cryptocurrency with longest history. However, a cryptocurrency with SSE being deployed would have different metrics values. Thus results from this section got with the Bitcoin statistical data should be considered as initial.

We study money flows in a space-scarce economy while dividing them into two types. Miners claim lost coins and also charge every output in the system state every block. Users are incentivized to move coins more frequently thus increasing mining rewards due to increased economic activity.  

\subsection{Lost coins recirculation}
\label{sec:re}

The need of lost coins recirculation has been discussed in literature~\cite{gjermundrod2014recirculating, gjermundrod2016going} in regards with combat deflation that will inevitably occur in cryptocurrencies with fixed supply. Coins declared supply is known by cryptocurrency design, but available supply is not known due to lost coins locked in outputs that will never be spent~\cite{ron2013quantitative}. On the other hand, deflation is a real problem in the traditional monetary system, however, it is still an open question whether it will be problematic for the Bitcoin economy~\cite{bitcoinDeflationarySpiral, barber2012bitter}.


Our model provides lost coins recirculation mechanism by design while its properties vary from model implementation and parameters. In this section we study how lost coins recirculation depends from the both.

Fee for keeping output of size \textit{B} is the \state{} for \textit{L} blocks is ${K \cdot B \cdot L}$. In \textit{Postpaid} and \textit{Scheduled payments} models space-time fee is taken from output value itself so when keys for an output which value is \textit{$V_{output}$} are lost the coins will be taken back to circulation after \textit{$L_{max}$} blocks: 

\begin{equation}
{L_{max} = {V_{output} \over K \cdot B}}
\end{equation}

Maximum lifetime of a concrete output depends on the miner-controlled \textit{K} parameter and user-defined output size and value. For a typical case in Bitcoin:

\begin{equation}
{L_{max} \approx {1 \over 100 \cdot K}}
\end{equation}

From this equation it is possible to calcualte \textit{K} by specifying target maximum output lifetime. For example, in case of 50 years period of full recirculation for an output value \textit{K} parameter would be $10^{-9}$. Significant difference between \textit{Postpaid} and \textit{Scheduled payments} is that in \textit{Postpaid} all coins will return to economy all at once after potentially big $L_{max}$ period, while in the \textit{Scheduled payments} mode they will return to economy by portions during this period. This makes \textit{Scheduled payments} preferable to \textit{Postpaid} because lost coins from big enough outputs in \textit{Postpaid} will not return to the circulation in foreseeable future. Anyway coins recirculation rate for both the modes in a long-term would be calculated as

\begin{equation}
R_{postpaid} = R_{scheduled} = {N_{lost} \cdot V_{output} \over L_{max}} = {N_{lost} \cdot K \cdot B}
\end{equation}

where $N_{lost}$ is the number of outputs with lost keys. Assuming current Bitcoins statistics, $N_{lost}\approx10^6$ and $K = 10^{-9}$ we can estimate, that $\approx0.036$ bitcoin are to be released from abandoned outputs in every block.

In the \textit{Prepaid} mode an user defines $L_{max}$ by himself when he creates an output and number of released coins after $L_{max}$ is equals to output value $V_{output}$ rater than much smaller space-time fee $f_s$. Note here, that $L_{max}$ do not directly depends on \textit{K} and coins recirculation rate will only depend on $V_{output}$, user-defined $L_{max}$ and number of lost outputs $N_{lost}$:

\begin{equation}
R_{prepaid} = {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

Assuming that $K\approx10^{-9}$ we can estimate difference between prepaid and postpaid models:

\begin{equation}
{R_{prepaid} \over R_{postpaid}} = {V_{output} \over  K \cdot B \cdot L_{max}} \approx {10^7 \over L_{max}}
\end{equation}

For example, if user-defined coin recirculation period $L_{max}\approx10$ years then ${R_{prepaid} \over R_{postpaid}} \approx 19$

Concluding the section, \esse{} model by design provides a way to return lost coins to circulation thus preventing potential deflation. \textit{Postpaid} model has a disadvantage  that lost coins could be returned to circulation in far future. In \textit{Prepaid} model coin recirculation rate is presumably much higher than in other models and \textit{Scheduled payments} mode is a most smooth way to recycle coins.



\subsection{User-Driven Money flow}
\label{sec:flow}

From users point of view, the longer you keep some output, the bigger space-time fee you pay. Thus the proposed fee regime provides an incentive to move coins stimulating economic activity. In all the fee models introduced in Section~\ref{sec:model}, user pays ${K \cdot B}$ coins every block for keeping his output in the state. 


\ignore{
  If he uses blockchain with output size \textit{B} is relatively small and do not depend on output value.

  To estimate money flow let's assume, that user will move his money when space-time fee will start dominate over other transactional costs \dnote{why?}. Thus we can estimate expected mean output lifetime as

  \begin{equation}
  \label{eq:ltmean}
  L_{mean}={f_p \over K \cdot B}
  \end{equation}
}

Currently in Bitcoin $N_{moved}$ outputs are moved in a block, and this number can be defined as: 

\begin{equation}
N_{moved} = {N_{utxo} \over L_{mu}} % = {N_{utxo} \cdot K \cdot B \over f_p}
\end{equation}

where $L_{mu}$ is mean lifetime of an output. We can define $L_{mu}$ as:
\begin{equation}
L_{mu} = {N_{utxo} \over {N_{moved}}}
\end{equation}

In Bitcoin, $L_{mu} \approx 8182$ blocks.


With \esse{} fee component enabled users move coins more frequently, thus mean lifetime becomes $L_{mi} < L_{mu}$. It is hard to estimate $L_{mi}$ as it depends on K and also on blockchain-specific usage scenarios. Increasement in money flow could be calcualted as:

$\Delta N_{moved} = {N_{utxo} \over L_{mi}} - {N_{utxo} \over L_{mu}} = N_{utxo} \cdot {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}}$


\ignore{
  In the \textit{Scheduled payments} mode there is an additional component in the flow which is miners moving an output every $D_s$ blocks:

  \begin{equation}
    N_{scheduled} \approx {N_{utxo} \over D_s}
  \end{equation}



  We can find a ratio between $N_{incentivized}$ and ${moved}$:

  \begin{equation}
    r_{flow} = {N_{incentivized} \over N_{moved}}  \approx {8180 \over L_{max-mean}} % = {N_{utxo} \cdot K \cdot B \over f_p}
  \end{equation}

  For example, if a user pays for $8180$ blocks~(about 57 days) on average in the \textit{Prepaid} model, money flow doubles in comparison with a system without \esse{} component.  


  For \textit{Scheduled payments}:

  \begin{equation}
    r_{flow} = {{N_{incentivized} + N_{scheduled}} \over N_{moved}} % = {N_{utxo} \cdot K \cdot B \over f_p}
  \end{equation}
}

\ignore{
  and share of coins moved in a block:

  \begin{equation}
    M_{flow} \approx { N_{transactions} \cdot V_{output} \over N_{coins}} = {K \cdot B \over f_p}
  \end{equation}

  Thus, money flow may be controlled with \textit{K} parameter. This formula provide a way to estimate \textit{K} based on current Bitcoin statistics:

  \begin{equation}
    K={M_{flow} \cdot f_p \over B} \approx {10^{-9}} ({BTC / (Byte \cdot Block)})
  \end{equation}

  For a mean output size of 36 Bytes space-time fee part will exceed propagation fee after 5555 blocks or 38 days. 
  %This means, that for active users, who spend their money more often than once a month, space-time fee will be negligible relative to propagation fee.

  From money flow analysis we can find out how to use \esse{} model to control cryptocurrency money flow, changing space-time price and encourage active economy participants. Another money flow analysis result is the dependency between $L$ and $K$ \ref{eq:ltmean} that can particularly by used in the \textit{Scheduled payments} model to reduce number of model parameters.
}




\subsection{Miner rewards}
\label{minerrew}
Incentivizing mining is very important for viability of a cryptocurrency economy. 
In addition to usual propagation fee, \esse{} provides two new sources for miner income: a space-time fee and lost coins in the \textit{Prepaid} model.

Thus in the \textit{Prepaid} model:
\begin{equation}
M_{3} = M_{propagation} + M_{space-time} + M_{lost}
\end{equation}

In other models:
\begin{equation}
M_{2} = M_{propagation} + M_{space-time}
\end{equation}

We now calculate the difference with reward $M_{pg}$~(propagation fees) miners have in Bitcoin. We assume that number of inputs per transaction is the same, then number of transactions as well propagation fees are to be increased in the same way as $N_{moved}$:

\begin{equation}
M_{propagation} = M_{pg} \cdot(1 + {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}})
\end{equation}



\ignore{
  In Section \ref{sec:flow} we have noticed, that \esse{} users have an incentive to actively use their coins and propagation reward is correlated with space-time reward:

  \begin{equation}
    M_{propagation} = r_{flow} \cdot M_{space-time} + M_{pg}
  \end{equation}

  where $C$ is non-negative constant. 
}

A space-time reward depends on state size and space-time price $K$ only:

\begin{equation}
M_{space-time} = \sum_{i=1}^{N_{utxo}} K_i \cdot B_i \approx K \cdot N_{utxo} \cdot B
\end{equation}

Recirculation reward was calculated in previous section and depends on space-time fee model. However it can be generalized as with $K_{model}$ parameter, that is equals to 1 for \textit{Scheduled payments} and \textit{Postpaid} models, and $K_{model} \approx 20$ \dnote{$K_{model} is not used anywhere!$} for \textit{Prepaid} model:

\begin{equation}
M_{lost} = {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

Thus the additional mining reward is:

\begin{equation}
\Delta M_2 = M_2 - M_{pg} = M_{pg} \cdot {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}} + K \cdot N_{utxo} \cdot B
\end{equation}

\begin{equation}
\Delta M_3 = M_{pg} \cdot {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}} + K \cdot N_{utxo} \cdot B + {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

\ignore{
  \begin{equation}
  \label{eq:reward}
    M_{reward} \approx M_{pg} + (K \cdot B) \cdot ((1 + r_{flow}) \cdot N_{utxo} + r_{mode} \cdot N_{lost})
  \end{equation}

  First part of this equation $M_{pg}$ is the reward of miner in existing fee models, the rest is the unique reward for \esse{} model.  In a sensible assumption $N_{utxo} >> N_{lost}$ equation \ref{eq:reward} can be simplified to

  \begin{equation}
    M_{postpaid} \approx M_{pg} + K \cdot B \cdot N_{utxo} \cdot (1 + M)
  \end{equation}

  that allows to estimate such $K$, when additional \esse{} reward will exceed common propagation reward $M_{pg}$:

  \begin{equation}
    K = {M_{pg} \over B \cdot N_{utxo} \cdot (1 + M)} \approx 10^{-9} ({BTC / (Byte \cdot Block)})
  \end{equation}

  that is naturally coincide to estimations from section \ref{eq:ltmean} while miner reward equals to user losses.
}

We remark that space-time reward $K \cdot N_{utxo} \cdot B$ does not depend on network throughput and can be easily predicted. Since it will be accrued to generator of block with concrete height, it may be considered as a constant block reward fixing problem of blockchain instability without block reward \cite{carlsten2016instability}. This value may be controlled by adjusting $K$ parameter making mining more stable and thus securing the network.

\dnote{What is an output value when miner is interested in collecting it?}

\subsection{State size}

In this section we analyze the main goal of \esse{} model which is to control state size. We study two most important cases. First, we estimate how big the state should be to give miners rewards comparable to Bitcoin's constant reward of today. Second, we study what is the maximum size of state could be considering an user having all the coins in the system 
and performing constant spam attack.


\paragraph{Constant Rewards}

For a state of size $S$ miner is getting $S \cdot K$ space-time fees every block. To be a replacement for a constant reward in Bitcoin of today $R_f$, following equality should holds:

\begin{equation}
\label{eq:statesizeexp}
S \cdot K = R_{f}
\end{equation}

which leads to 13 Gb state for $K=10^{-9}$ ($BTC / (Byte \cdot Block)$).


\paragraph{Spam Attack}

We consider an attacker who creates an output roughly of size of a block $S_{block}$ for every block in a row. Initially the attacker has all the $N_{coins}$ of the system and he does not buy new coins during the attack~(miners do not sell the coins to him). We assume that $K$ is constant during the attack~(however, in real world miner would likely raise $K$ during the attack). As soon as each block space-time fee $K \cdot B$ should be paid for all previously created outputs, maximum possible number of such outputs $O_{max}$ is to be calculated from equation:

\begin{equation}
N_{coins} = \sum_i^{O_{max}}{K \cdot S_{block} \cdot i} = K \cdot S_{block} \cdot ( O_{max}^2 + O_{max}) / 2 \approx K \cdot S_{block} \cdot O_{max}^2 / 2
\end{equation}

assuming that number of unspent outputs is big enough. Resulting state size: 

\begin{equation}
\label{eq:statesizemax}
S = S_{block} \cdot O_{max} = \sqrt { 2 \cdot N_{coins} \cdot S_{block} \over K}
\end{equation}

which is about 183 gigabytes for Bitcoin statistics and $K=10^{-9}$ ($BTC / (Byte \cdot Block)$). Taking into account that \state{} should be kept in memory, 183GB is quite big state size, however modern RAM discs allows to keep it. Note also that it is upper-bound of \state{} size calculated from non-realistic assumptions that all available supply will be paid for space-time fee, and $K$ is constant.


Thus \esse{} model allows to control state growth with $K$ parameter and allows to estimate expected state size as well as an upper bound. Reasonable $K$ value leads to 13 Gb of expected state size and 183 GB for a spam attack backed by all the tokens in the system. The model is preventing spam attacks like \cite{bitcoin2015flood} and provide a guarantee that miners can have state fit in RAM.


\paragraph{Cryptocurrency inflation}

As we have already noticed in section \ref{minerrew}, miners reward from space-time fee can be considered as static block reward. Extending this idea it is possible to get rid of coinbase transactions breaking usual transaction rule that sum of inputs should not be less then sum of outputs. To achieve this, all coins should be issued in genesis block in such a way, that every block one output will be released and miner will collect its value according space-time fee model. Thereafter miner will collect reward in uniform way collecting abandoned outputs, whenever it was created in genesis or by cryptocurrency user.

After all coins issue, nothing changes from both miners and users point of view: part of users money move every block to miner. Note, that it is isomorphic to inflation in existing cryptocurrencies, when users accumulations remain the same, but total supply increases via static miner reward.

\section{Examples}

\knote{moneychain and datachain}

\section{Subsidizing Space-time}

It is usual to pay for space-time multiplication for database leasing and thus \esse{} model is natural for blockchain-as-database model. On the other hand, in blockchain usage for currency it may be natural to allow users to keep some data for free in blockchain. In this section we are going to extend \esse{} model, subsidizing pre-defined by network space-time $S_s$ (which may also be defined by miners voting). For example, it may allow to keep simple money output for 10 years for free, subsidizing $S_s \approx 525600 (Blocks) \cdot 35 (Byte) \approx 18 (Mb \cdot Block)$. While 10 years is a quite big period for regular output, it is quite small amount of subsidized space-time for blockchain usage as a storage, e.g. will only allow to keep 127 Kb output for one day in \state{}.

Such subsidized fee may be calculated as

\begin{equation}
f_{s} = max(0, K \cdot B \cdot L - S_s)
\end{equation}

and provides another way to control \esse{} economy with $S_s$ parameter. In particular it allows define $K$ and $S_s$ to achieve desired money flow and coin recirculation rates. It is possible to estimate $K$ and $S_s$ required for mean output lifetime $L_{mean}$ and mean coin recirculation periods $R_{mean}$ using assumptions from previous section:

\begin{equation}
  \begin{array}{ccl}
   K \cdot B \cdot L_{max} - S_s & = & V_{output} \\
   K \cdot B \cdot L_{mean} - S_s & = & f_p
  \end{array}
\end{equation}

Assuming $L_{mean}=1$ year and $L_{max}=10$ years and Bitcoin statistics, we may estimate values of $K$ and $S_s$:

\begin{equation}
  \begin{array}{ccl}
   K & = & {V_{output} - f_p \over B \cdot (L_{max} - L_{mean})} \approx \quad 2*10^{-8} ({BTC / (Byte \cdot Block)}) \\
   S_s & = & {(V_{output} - f_p) \cdot L_{mean} \over (L_{max} - L_{mean})} - f_p \approx 0.04\quad(BTC)
  \end{array}
\end{equation}

which is equals to 2 ($Mb \cdot Block$) for free for each ouptut. This is exactly the increasing of upper bound for \state{} size because according to equation \ref{eq:statesizemax} subsidized space-time will just prolongate outputs lifetime for corresponding value. Moreover according equation \ref{eq:statesizemax} expected \state{} size will remain the same because it is dictated by economical reasons only.

Thus, additional subsidized space-time parameter allows to use the same blockchain for both money and data applications. Subsidized value may be configured to be big enough for regular users, allowing them to keep their outputs for free for some time, but small enough for blockchain usage as database. Its impact to \state{} size is negligible, while it allows to increase $K$ value painlessly for regular users, but increasing lost coin recirculation rate.


\section{Related Work}

\knote{PascalCoin?}

\section{Further Work}

\dnote{transaction commission may be defined as $fee = Max(f_{v}, f_p, f_s)$}

\dnote{Comparison with Gesell's money~(money with demurrage)}

\section{Conclusion}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\end{document}
