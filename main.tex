\documentclass[]{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\newtheorem{axiom}{Axiom}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}


\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{blue}{Dima notes}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\esse}{Esse}
\newcommand{\state}{\textit{State}}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\begin{document}

\title{\esse{}: Space-scarce economy model for cryptocurrencies}
\author{Dmitry Meshkov and Alexander Chepurnoy, IOHK Research}
\maketitle

\section{Introduction}

Bitcoin \cite{Nakamoto2008} has been invented in 2008 by Nakamoto as a purely peer-to-peer version of electronic cash. \dnote{more words about bitcoin as an economy}

Any cryptocurrency should satisfy at least 2 properties needed by the ledger assuming an honest majority and arbitrary adversarial behavior \cite{Garay2015}. First of them, \textit{Persistence} states that once a transaction goes more than k blocks "deep" into the blockchain of one honest player, then it will be included in every honest player's blockchain with overwhelming probability, and it will be assigned a permanent position in the ledger. Another basic property \textit{Liveness} says that all transactions originating from honest account holders will eventually end up at a depth more than k blocks in an honest player's blockchain, and hence the adversary cannot perform a selective denial of service attack against honest account holders.

Bitcoin satisfies \textit{Liveness} property when honest miners are expected to be altruistic and adds transactions to blocks even if it's not profitable for them. On the other hand, rational miner won't include all valid transactions into blocks, because due to the increased chances of orphaning a block, the cost of adding transactions to block is not zero\cite{rizun2015transaction, andresen2013}. As it was shown in \cite{rizun2015transaction}, even in absence of block size limit, Bitcoin fee market is healthy and the miners surplus is maximized at a finite quantity of block space, and thus the miner is incentivized to produce a finite block. This means, that only subset of transactions, providing enough fee for miners will be included in blocks and both miners and users needs explicit rules how to calculate transaction fee in current environment. \cite{rizun2015transaction} provide a way, how to calculate transaction fee regarding block propagation time, i.e. miners network resources utilization. We argue, that this is not the only component of the transaction fee, because miner also utilize other his resources that should be considered.

Besides of network utilization, transaction processing requires computations from miner. For most of cryptocurrencies transactional language is limited \cite{script}, their validation is very fast and this cost may not be considered, but for cryptocurencies with rich transaction language \dnote{more links e.g. for sigma-state} this cost is not negligible. In so-called smart contract languages \cite{seijas2016scripting, tezosScript, solidity} transaction processing may require a lot of computations and computational costs are included to transaction fees there. This cost is specific to concrete transactional language and is out of scope of this paper.

The main purpose of this paper is to consider third component of the transaction fee, that is related with increasing local miners \state{}. In all known cryptocurrencies, when a miner accepts a transaction that increases it's current \state{}, he takes on a liability equal to the present value of the cost of storing those new outputs indefinitely far into the future. This in not healthy situation that is leading to continuously increasing \state{} \cite{utxoChart}, e.g. number of unspent transaction outputs increases by 12000 every year in Bitcoins. Moreover state size may increase very fast during spam attack, e.g. 15000 additional outputs where added to Bitcoins UTXO during spam attacks in July 2015 \cite{bitcoin2015flood} and most of this outputs are not spent yet. Thus miner's \state{} may significantly increases during attacks and this attacks are free for adversary, meaning that transaction fee for increasing \state{} size is 0. Note, that for efficient block processing, \state{} should be kept in memory, otherwise attacks where miner generate block that will be validated for a long time by other miners come into being \dnote{link to ethereum DoS, + others?}. Big \state{} size leads to centralization, where hardware requirements are too big for common users, and to SPV mining, where miners are tring to generate a new block without transaction validation of previous one. In July 2015 this resulted in invalid chain of 6 blocks\cite{spvMining}, that is enough to perform double-spend attack in most of Bitcoin applications. To prevent \state{} growing, this third fee component should depend from size of inputs, destroyed by this transaction, size of outputs, create be it and their expected time to live. Later in this paper we will call it a \textit{state space-time fee}.

In this paper we propose a model, where users should pay fee for multiplication of the time output data should be kept in \state{} to it's size. This is very usual for most of storage services, where users pay for the gigabyte of data per month. Such an approach prevents putting any data to miners storage forever, leading to situation, where miners can control their \state{} size with fee. Our model design is described in section~\ref{sec:model} while it's consequences for cryptocurrency economy are described in section~\ref{sec:analysis}.  \dnote{paper structure}

\dnote{write somewhere about lost coins and deflation}

\section{The Model}
\label{sec:model}

Most of users think about blockchain as something enough for a fullnode to work successfully~(and efficiently). In fact, the blockchain itself is not enough for performance and even security reasons. Nodes in Bitcoin are holding a set of unspent outputs in order to validate efficiently an arbitrary transaction. Similarly, Ethereum\cite{ethyp} has a concept of "world state", and some aspects of a particular state representation are inbuilt into the protocol. \esse{} model is based on \state{}-centric design and have the main purpose to make \state{} size controllable by miners.

As we have already mentioned above, in our model transaction fee consists of 3 parts: \textit{validation cost}, \textit{propogation cost} and \textit{state space-time difference cost}.

\begin{equation}
fee = fee_{validation} + fee_{propogation} + fee_{space\_time}
\end{equation}

 \dnote{should we require from total fee to be positive?}

Validation and propogation costs are strictly positive, and assumed to be independent from space-time fee. We also assume, that space-time fee impact to total fee may range from negliable to dominant. Space-time fee component may be both positive and negative, since transaction may both increase and decrease \state{} size. It's dependency from size of inputs, outputs and their time to live may vary depending on the cryptocurrency purpose. Any transactoin remove some data from state, freeing some space-time \textit{$ST_{cleared}$} and add some data to it, filling space-time \textit{$ST_{filled}$} and resulting space-time fee can be calculated as follows:

\begin{equation}
fee_{space\_time} = K \cdot (ST_{filled} - ST_{cleared})
\end{equation}

where \textit{K} is a space-time price in the fee tokens. This price depends on hardware price for miners and token exchange rate, so \textit{K} is not a static value. We assume, that miners can change this pricing via mechanism like ``gas'' in Ethereum and thus control cost of blockchain support.

In most of existing cryptocurrencies it's not clear, how to calculate \textit{$ST_{filled}$} and \textit{$ST_{cleared}$}. Sizes of old and new outputs are known, while it is not possible to calculare expected in existing blockchain setups. To do this, transactional language should support both regular cryptography operations, like signature validation, and environment operations, like blockchain height and transaction, that is trying to spend this output. Later we assume cryptocurency, that support this operations, and will try to analize different variants of \textit{$fee_{space\_time}$} dependency. In all of them \textit{$ST$} is proportional for multiplication of the time output data should be kept in \state{} to it's size, while concrete rules how to enforce user to pay space-time fee are different.

\subsection{Prepaid outputs}

First model we are going to analyze is prepaid outputs. In it each output represents a box of fixed size \textit{BS} in a \state{} and prepaid until explicitly known period of time \textit{LT}. After \textit{LT} anyone ~(presumably miner, generated first block after that) will be able spend this overdue output. Thus spending script for all outputs will be a combination of regular spending script and loan period \textit{LT}:

\begin{equation}
(Height > LT) \lor (regular\_script)
\end{equation}

where \textit{Height} is current blockchain height and \textit{regular\_script} is user-defined output spending script. This lifetime part of a script is a part of consensus, and space-time transaction fee is paid at the time of output creation:

\begin{equation}
fee_{prepaid} = K \cdot (\sum_i{(BS_i \cdot (LT_i - Height))} - \sum_j{(BS_j \cdot (LT_j - Height)}))
\end{equation}

\subsection{Postpaid outputs}

In the second model, user should pay fee for taken space-time in \state{} when he spends output. When output is spent it's lifetime is known, so resulting transaction fee can be calculated:

\begin{equation}
fee_{postpaid} = \sum_i{(K_i \cdot BS_i \cdot (HS_i - HC_i))}
\end{equation}

where \textit{$HS_i$} and \textit{$HC_i$} are heights, where i-th output was created and spent respectively. Note, that each output has it's own space-time \textit{$K_i$}, corresponding to \textit{K} value at it's creation time. Here we can note, that if output value is \textit{V}, then height \textit{$H_{max}$} exists, where all the transaction value will be taken by space-time fee.

\begin{equation}
H_{max} = {{HC + V} \over {K \cdot BS}}
\end{equation}

After that anyone should be able to spend this output, sending all it's value to transaction fee and spending script will looks like

\begin{equation}
(Height > H_{max}) \lor (regular\_script)
\end{equation}

\subsection{Leaking balance}

The last model we are going to analyze is a combination of prepaid and postpaid models. Like in postpaid model, user pays for each his output when we spends it in an outgoing transaction, but is enforced to move his coins before a known time \textit{$HS$}. If the user do not do this, anyone can create a transaction with this output, returning them to owner without fee-space fee ${K \cdot BS \cdot LT}$. In this model \textit{LT} is another protocol parameter, that may be fixed by protocol design or changed via miners voting like \textit{K}.

\section{Analysis of The Model}
\label{sec:analysis}

In this section we are going to provide comprehensive analysis of \esse model. Besides of it's main goal to control state size, it provides additional benefits as side-effects, that can be used in cryptocurrency design. Our further analysis will be based on the following stats from current Bitcoin network:

\begin{itemize}
  \item Number of unspent transaction outputs: $N_{UTXO}=45000000$
  \item Number of coins in circulation: $N_{coins}=16000000$ BTC
  \item Mean number of coins in one output: $V_{output}=0.35$ BTC
  \item Simple payment transaction fee: $fee_{propagation}=0.0002$ BTC
  \item Mean output size: $BS=36$ Bytes
  \item Per cent of coins, moved in every block: $M_{flow}=0.013$ \%
  \item Time interval between blocks: $T_{block}=10$ minutes
\end{itemize}

\subsection{Money flow}

From users point of view, the longer you keep some output, the bigger space-time fee you pay. Thus \esse{} provides an incentive to move your coins stimulating economic activity. In all fee models, described in section~\ref{sec:model}, user pays ${K \cdot BS}$ coins every block for keeping his output into \state{}. If he use blockchain with \esse{} as a money chain, output size \textit{BS} is relatively small and do not depend on output value.

To estimate money flow let's assume, that user will move his money when space-time fee will start dominate over other transactional costs an therefore creation of transaction will be almost free for him. Thus we can estimate expected mean output lifetime as

\begin{equation}
\label{eq:ltmean}
LT_{mean}={fee_{propagation} \over K \cdot BS}
\end{equation}

Since there are $N_{UTXO}$ in a system and each of them contains $V_{output}$ coins, we can estimate per cent of coins, that will be moved in each block incentivised by \esse{} model:

\begin{equation}
M_{flow}={N_{UTXO} \cdot V_{output} \over LT_{mean} \cdot N_{coins}}=K \cdot {N_{UTXO} \cdot V_{output} \cdot BS \over fee_{propagation} \cdot N_{coins}} = K \cdot {BS \over fee_{propagation}}
\end{equation}

Thus, money flow may be controlled with \textit{K} parameter. This formula provide a way to estimate \textit{K} based on current Bitcoin statistics:

\begin{equation}
K={M_{flow} \cdot fee_{propagation} \over BS} \approx {10^{-9}}{(BTC / (Byte \cdot Block))}
\end{equation}

For regular outputs of 36 Bytes space-time fee part will exceed propagation fee after 56000 blocks or 388 days. This means, that for active users, who spend their money more often than once a year, space-time fee will be negligible relative to propagation fee.

From money flow analysis we can conclude, that \esse{} model make sense even in cash-only chains, where output size is fixed and very slow - cryptocurrency can control it's money flow, changing space-time price and encourage active economy participants. Another money flow analysis result is the dependency between $LT$ and $K$ \ref{eq:ltmean}
 that can particularly by used in the \textit{Leaking balance} model to reduce number of model parameters.

%Considering total $1.6\cdot10^7$ of Bitcois in c circulation, we can conclude, that user should pay for about $6\cdot10^{-17}$ of total supply every block for every byte in output.

\subsection{Lost coins recirculation}

The need of recirculating lost coins was widely discussed in cryptocurrencies \cite{gjermundrod2014recirculating, gjermundrod2016going} in order to combat deflation that will inevitably occur in cryptocurrencies with the fixed amount of coins to be circulated. Coins declared supply is known by cryptocurrency design, but available supply is unknown due to lost coins, locked in outputs that will never be spent \cite{ron2013quantitative}. On the other hand deflation is a real problem in the traditional monetary system, but it is still open question, whether it will also be a problem in the Bitcoin economy \cite{bitcoinDeflationarySpiral, barber2012bitter}.

While negative impact of deflation to cryptocurrencies is not proven, most of researchers agree in need of lost coins recirculating. \esse{} model provide lost coins recirculation mechanism by design, while it's properties vary from model implementation and parameters. In this section we are going to estimate lost coins recirculation dependency from chosen model and it's parameters.

Fee for keeping output of size \textit{BS} is the \state{} for \textit{LT} blocks is ${K \cdot BS \cdot LT}$. In \textit{Postpaid} and \textit{Leaking balance} models space-time fee is taken from output value itself, so when keys for output with \textit{$V_{output}$} coins are lost, they will return to economy after \textit{$LT_{max}$} blocks, where

\begin{equation}
{LT_{max} = {V_{output} \over K \cdot BS}}
\end{equation}

Maximum lifetime of a concrete outputs depends on miner-controlled \textit{K} parameter and user-defined output size and value. As in previous section we will estimate this dependency based on Bitcoin stats:

\begin{equation}
{LT_{max} \approx {1 \over 100 \cdot K}}
\end{equation}

Based on this equation, it is possible to chose \textit{K} keeping in mind desired maximum ouptut lifetime. Desiring 10 years period of coins fully recirculation, \textit{K} parameter should equals $10^{-6}$ that is much bigger than $10^{-9}$ from previous section \dnote{$??? 10 is too small, you'll be able to spend only hlaf of your money after 5 years$}. Regarding lost coins recirculation, significant difference between \textit{Postpaid} and \textit{Leaking balance} is that in \textit{Postpaid} all coins will return to economy all at once after some quite big $LT_{max}$ period, while in \textit{Leaking balance} they will return to economy by small portions during this period. This makes \textit{Leaking balance} preferable to \textit{Postpaid}, because lost coins from big enough outputs in \textit{Postpaid} will not return to the circulation in foreseeable future. Anyway in a log-term equilibrium conditions coins recirculation rate of both models will be calculated as

\begin{equation}
R_{postpaid} = R_{leaking} = {N_{lost} \cdot V_{output} \over LT_{max}} = {N_{lost} \cdot K \cdot BS}
\end{equation}

where $N_{lost}$ is the number of outputs with lost keys. Assuming current Bitcoins statistics and $N_{lost}\approx10^6$ we can estimate, that $\approx0.036$ BTC will be released from abandoned outputs keys every block.

In \textit{Prepaid} model user define $LT_{max}$ by himself when he creates output and number of released coins after $LT_{max}$ is equals to output value $V_{output}$ rater than much smaller space-time fee $fee_{space\_time}$. Note here, that $LT_{max}$ do not directly depends on \textit{K} and coins recirculation rate will only depend on $V_{output}$, user-defined $LT_{max}$ and number of lost outputs $N_{lost}$:

\begin{equation}
R_{prepaid} = {N_{lost} \cdot V_{output} \over LT_{max}}
\end{equation}

Let's assume user-defined coin recirculation period $LT_{max}\approx10$ years and $K\approx10^{-9}$ from previous section, we can estimate difference between prepaid and postpaid models:

\begin{equation}
{R_{prepaid} \over R_{postpaid}} = { V_{output}  \over  K \cdot BS \cdot LT_{max}} \approx 20
\end{equation}

%R_{postpaid} = R_{leaking} = {N_{lost} \cdot V_{output} \over LT_{max}} = {N_{lost} \cdot K \cdot BS} = 10^6 * 10^(-9) * 35 = 0.035
%R_{prepaid} = {N_{lost} \cdot V_{output} \over LT_{max}} = 10^(6) * 0.36 /  = 0.684931507
%  \item Mean number of coins in one output: $V_{output}=0.35$ BTC
%   \item Simple payment transaction fee: $fee_{propagation}=0.0002$ BTC

 \dnote{Check, should be something like 1000}

Thus \esse{} model by design provide a way to return lost coins to circulation, preventing deflation risks. \textit{Postpaid} model has a disadvantage, that lost coins will be returned to circulation in a far future, in \textit{Prepaid} model coin recirculation rate is much higher than in other models and \textit{Leaking balance} model is a smoother way of coin recirculation.

\subsection{Miner rewards}

Mining reward is very important for cryptocurrency economy - in original paper\textit{Nakamoto2008} it's assumed, that miners are incentivized to fair befaviour, while recent researches showed, that it is not always correct \cite{carlsten2016instability, Eyal2014}. \esse{} model provide a new way to be rewarded by collecting garbage outputs, increasing miner profit.

%\textbf{new way to be rewarded} by collecting garbage. With this reward, fixed block reward is not required any more for network stability \dnote{link to instability of Bitcoin without block reward} and allows \ergo to stop emission quite soon. Moreover with this economy miners will have \textbf{lower-bound for their rewards}, providing more stable mining and, therefore, secure network.

\dnote{Miners are getting a new kind of profit}

\dnote{Expected minimum miner rewards with no coins ever lost in some UTXO model(constant? growing?)}

\dnote{What is an output value when miner is interested in collecting it?}

\dnote{Minimal and expected money flow}

\subsection{??? }

\dnote{All the money can be issued in genesis, with release 1 output per block}

\subsection{Comparison with Gesell's money}


\subsection{State size}
\dnote{Max and expected state size}

%Another \esse{} feature, important for miners, is that it provides fee \textbf{mechanism to control state size}, preventing network centralization on a few amount of very powerful computers

\dnote{Comparison with Gesell's money~(money with demurrage)}

\subsection{Subsidified space-time}

\dnote{transaction commission may be defined as $fee = Max(fee_{validation}, fee_{propogation}, fee_{space\_time})$}

\dnote{describe like possible optimization}

$fee_{space-time\_cost} = K \cdot (\sum{(new\_output\_size \cdot lifetime - S_s)} - \sum{(old\_output\_size \cdot remaining\_lifetime - S_s)})$
$S_s$ is a subsidified space-time amount (e.g. 500 byte-years which is about free storage for 10 years for a standard 50 bytes output)



\section{Related Work}

\section{Conclusion}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\end{document}
