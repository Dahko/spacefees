\documentclass[]{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\newtheorem{axiom}{Axiom}

\usepackage{systeme}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}


\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{blue}{Dima notes}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\esse}{\textit{Esse}}
\newcommand{\state}{\textit{State}}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\begin{document}

\title{On Space-Scarce Economy In Blockchain Systems}
\author{Dmitry Meshkov and Alexander Chepurnoy, IOHK Research}
\maketitle

\begin{abstract}
In this paper we study space-scarce economy in massively replicated open blockchain systems, like Bitcoin. In such systems, memory to hold the balance sheet becomes the most scarce resource eventually. Currently only technical solutions, not economic, are proposed in order to tackle the problem. The problem becomes even harder for blockchain systems used to store data~(votes, certificates, logs etc.). We propose to add a new component to a fee regime, fees based on how much additional space will be needed for the balance sheet in result of transaction processing, and fow how long newly created records will live.    
\end{abstract}

\section{Introduction}

Bitcoin \cite{Nakamoto2008} has been invented in 2008 by Nakamoto as a purely peer-to-peer version of electronic cash. 

\dnote{more words about bitcoin as an economy}

Any cryptocurrency should satisfy at least 2 properties assuming an honest majority and arbitrary adversarial behavior \cite{Garay2015}. \textit{Persistence} guarantees that once a transaction goes more than $k$ blocks "deep" into the blockchain of one honest player, then it will be included in every honest player's blockchain with overwhelming probability, and it will be assigned a permanent position in the ledger. \textit{Liveness} guarantees that all transactions originating from honest participants will eventually end up at a depth more than $k$ blocks in an honest player's blockchain, and hence the adversary cannot perform a selective denial of service attack against honest account holders.

Bitcoin satisfies \textit{Liveness} property when honest miners are expected to be altruistic and adds transactions to blocks even if it's not profitable for them. However, a rational miner won't include all valid transactions into blocks, because due to the increased chances of orphaning a block, the cost of adding transactions to block is more than zero\cite{rizun2015transaction, andresen2013}. As shown in \cite{rizun2015transaction}, even in absence of block size limit, Bitcoin fee market is healthy and the miners surplus is maximized at a finite quantity of block space, and thus the miner is incentivized to produce a block of a limited size. This means, that only subset of transactions, providing enough fee for miners will be included in blocks and both miners and users needs explicit rules how to calculate transaction fee in current environment. \knote{Isn't this claim way too bold and unproven?} \cite{rizun2015transaction} provides a procedure to calculate transaction fee based on block propagation time, i.e. miners network resources utilization. We argue, that this is not the only component of the transaction fee, because miner also utilize other his resources that should be considered.

Besides of network utilization, transaction processing requires computations from miner. For most of cryptocurrencies transactional language is limited \cite{script}, their validation is very fast and this cost may not be considered, but for cryptocurencies with rich transaction language \dnote{more links e.g. for sigma-state} this cost is not negligible. In so-called smart contract languages \cite{seijas2016scripting, tezosScript, solidity} transaction processing may require a lot of computations and computational costs are included to transaction fees there. This cost is specific to concrete transactional language and is out of scope of this paper.

The main purpose of this paper is to consider third component of the transaction fee, that is related with increasing local miners \state{}. In all known cryptocurrencies, when a miner accepts a transaction that increases it's current \state{}, he takes on a liability equal to the present value of the cost of storing those new outputs indefinitely far into the future. This in not healthy situation that is leading to continuously increasing \state{} \cite{utxoChart}, e.g. number of unspent transaction outputs increases by 12000 every year in Bitcoins. Moreover state size may increase very fast during spam attack, e.g. 15000 additional outputs where added to Bitcoins UTXO during spam attacks in July 2015 \cite{bitcoin2015flood} and most of this outputs are not spent yet. Thus miner's \state{} may significantly increases during attacks and this attacks are free for adversary, meaning that transaction fee for increasing \state{} size is 0. Note, that for efficient block processing, \state{} should be kept in memory, otherwise attacks where miner generate block that will be validated for a long time by other miners come into being \dnote{link to ethereum DoS, + others?}. Big \state{} size leads to centralization, where hardware requirements are too big for common users, and to SPV mining, where miners are tring to generate a new block without transaction validation of previous one. In July 2015 this resulted in invalid chain of 6 blocks\cite{spvMining}, that is enough to perform double-spend attack in most of Bitcoin applications. To prevent \state{} growing, this third fee component should depend from size of inputs, destroyed by this transaction, size of outputs, create be it and their expected time to live. Later in this paper we will call it a \textit{state space-time fee}.

In this paper we propose a model, where users should pay fee for multiplication of the time output data should be kept in \state{} to it's size. This is very usual for most of storage services, where users pay for the gigabyte of data per month. Such an approach prevents putting any data to miners storage forever, leading to situation, where miners can control their \state{} size with fee. Our model design is described in section~\ref{sec:model} while it's consequences for cryptocurrency economy are described in section~\ref{sec:analysis}.  \dnote{paper structure}

\dnote{write somewhere about lost coins and deflation}

\section{The Model}
\label{sec:model}

Most of users think about blockchain as something enough for a fullnode to work successfully~(and efficiently). In fact, the blockchain itself is not enough for performance and even security reasons. Nodes in Bitcoin are holding a set of unspent outputs in order to validate efficiently an arbitrary transaction. Similarly, Ethereum\cite{ethyp} has a concept of "world state", and some aspects of a particular state representation are inbuilt into the protocol. \esse{} model is based on \state{}-centric design and have the main purpose to make \state{} size controllable by miners.

As we have already mentioned above, in our model transaction fee consists of 3 parts: \textit{validation cost}, \textit{propagation cost} and \textit{state space-time difference cost}.

\begin{equation}
fee = fee_{validation} + fee_{propagation} + fee_{space\_time}
\end{equation}

 \dnote{should we require from total fee to be positive?}

Validation and propagation costs are strictly positive, and assumed to be independent from space-time fee. We also assume, that space-time fee impact to total fee may range from negliable to dominant. Space-time fee component may be both positive and negative, since transaction may both increase and decrease \state{} size. It's dependency from size of inputs, outputs and their time to live may vary depending on the cryptocurrency purpose. Any transactoin remove some data from state, freeing some space-time \textit{$ST_{cleared}$} and add some data to it, filling space-time \textit{$ST_{filled}$} and resulting space-time fee can be calculated as follows:

\begin{equation}
fee_{space\_time} = K \cdot (ST_{filled} - ST_{cleared})
\end{equation}

where \textit{K} is a space-time price in the fee tokens. This price depends on hardware price for miners and token exchange rate, so \textit{K} is not a static value. We assume, that miners can change this pricing via mechanism like ``gas'' in Ethereum and thus control cost of blockchain support.

In most of existing cryptocurrencies it's not clear, how to calculate \textit{$ST_{filled}$} and \textit{$ST_{cleared}$}. Sizes of old and new outputs are known, while it is not possible to calculare expected in existing blockchain setups. To do this, transactional language should support both regular cryptography operations, like signature validation, and environment operations, like blockchain height and transaction, that is trying to spend this output. Later we assume cryptocurency, that support this operations, and will try to analize different variants of \textit{$fee_{space\_time}$} dependency. In all of them \textit{$ST$} is proportional for multiplication of the time output data should be kept in \state{} to it's size, while concrete rules how to enforce user to pay space-time fee are different.

\subsection{Prepaid outputs}

First model we are going to analyze is prepaid outputs. In it each output represents a box of fixed size \textit{BS} in a \state{} and prepaid until explicitly known period of time \textit{LT}. After \textit{LT} anyone ~(presumably miner, generated first block after that) will be able spend this overdue output. Thus spending script for all outputs will be a combination of regular spending script and loan period \textit{LT}:

\begin{equation}
(Height > LT) \lor (regular\_script)
\end{equation}

where \textit{Height} is current blockchain height and \textit{regular\_script} is user-defined output spending script. This lifetime part of a script is a part of consensus, and space-time transaction fee is paid at the time of output creation:

\begin{equation}
fee_{prepaid} = K \cdot (\sum_i{(BS_i \cdot (LT_i - Height))} - \sum_j{(BS_j \cdot (LT_j - Height)}))
\end{equation}

\subsection{Postpaid outputs}

In the second model, user should pay fee for taken space-time in \state{} when he spends output. When output is spent it's lifetime is known, so resulting transaction fee can be calculated:

\begin{equation}
fee_{postpaid} = \sum_i{(K_i \cdot BS_i \cdot (HS_i - HC_i))}
\end{equation}

where \textit{$HS_i$} and \textit{$HC_i$} are heights, where i-th output was created and spent respectively. Note, that each output has it's own space-time \textit{$K_i$}, corresponding to \textit{K} value at it's creation time. Here we can note, that if output value is \textit{V}, then height \textit{$H_{max}$} exists, where all the transaction value will be taken by space-time fee.

\begin{equation}
H_{max} = {{HC + V} \over {K \cdot BS}}
\end{equation}

After that anyone should be able to spend this output, sending all it's value to transaction fee and spending script will looks like

\begin{equation}
(Height > H_{max}) \lor (regular\_script)
\end{equation}

\subsection{Leaking balance}

The last model we are going to analyze is a combination of prepaid and postpaid models. Like in postpaid model, user pays for each his output when we spends it in an outgoing transaction, but is enforced to move his coins before a known time \textit{$HS$}. If the user do not do this, anyone can create a transaction with this output, returning them to owner without fee-space fee ${K \cdot BS \cdot LT}$. In this model \textit{LT} is another protocol parameter, that may be fixed by protocol design or changed via miners voting like \textit{K}.

\section{Analysis of The Model}
\label{sec:analysis}

In this section we are going to provide comprehensive analysis of \esse model. Besides of it's main goal to control state size, it provides additional benefits as side-effects, that can be used in cryptocurrency design. Our further analysis will be based on the following stats from current Bitcoin network:

\begin{itemize}
  \item Number of unspent transaction outputs: $N_{UTXO} \approx 45000000$
  \item Number of coins in circulation: $N_{coins} \approx 16000000$ BTC
  \item Mean number of coins in one output: $V_{output} \approx 0.35$ BTC
  \item Simple payment transaction fee: $fee_{propagation} \approx 0.0002$ BTC
  \item Mean output size: $BS \approx 36$ Bytes
  \item Per cent of coins, moved in every block: $M_{flow} \approx 0.013$ \%
  \item Time interval between blocks: $T_{block} \approx 10$ minutes
  \item Transaction fees per block: $R_{pg} \approx 1$ BTC
\end{itemize}

\subsection{Money flow}
\label{sec:flow}

From users point of view, the longer you keep some output, the bigger space-time fee you pay. Thus \esse{} provides an incentive to move your coins stimulating economic activity. In all fee models, described in section~\ref{sec:model}, user pays ${K \cdot BS}$ coins every block for keeping his output into \state{}. If he use blockchain with \esse{} as a money chain, output size \textit{BS} is relatively small and do not depend on output value.

To estimate money flow let's assume, that user will move his money when space-time fee will start dominate over other transactional costs an therefore creation of transaction will be almost free for him. Thus we can estimate expected mean output lifetime as

\begin{equation}
\label{eq:ltmean}
LT_{mean}={fee_{propagation} \over K \cdot BS}
\end{equation}

Since there are $N_{UTXO}$ in a system and each of them contains $V_{output}$ coins, we can estimate per cent of coins, that will be moved in each block incentivized by \esse{} model:

\dnote{start: estimate number of transactions per block}
Number of transactions:
\begin{equation}
N_{transactions} \approx {N_{UTXO} \over LT_{mean}} = {N_{UTXO} \cdot K \cdot BS \over fee_{propagation}}
\end{equation}

\begin{equation}
M_{flow} \approx { N_{transactions} \cdot V_{output} \over N_{coins}} = {K \cdot BS \over fee_{propagation}}
\end{equation}
\dnote{end: estimate number of transactions per block}

\begin{equation}
M_{flow}={N_{UTXO} \cdot V_{output} \over LT_{mean} \cdot N_{coins}}=K \cdot {N_{UTXO} \cdot V_{output} \cdot BS \over fee_{propagation} \cdot N_{coins}} = K \cdot {BS \over fee_{propagation}}
\end{equation}

Thus, money flow may be controlled with \textit{K} parameter. This formula provide a way to estimate \textit{K} based on current Bitcoin statistics:

\begin{equation}
K={M_{flow} \cdot fee_{propagation} \over BS} \approx {10^{-9}} ({BTC / (Byte \cdot Block)})
\end{equation}

For regular outputs of 36 Bytes space-time fee part will exceed propagation fee after 56000 blocks or 388 days. This means, that for active users, who spend their money more often than once a year, space-time fee will be negligible relative to propagation fee.

From money flow analysis we can conclude, that \esse{} model make sense even in cash-only chains, where output size is fixed and very slow - cryptocurrency can control it's money flow, changing space-time price and encourage active economy participants. Another money flow analysis result is the dependency between $LT$ and $K$ \ref{eq:ltmean}
 that can particularly by used in the \textit{Leaking balance} model to reduce number of model parameters.

%Considering total $1.6\cdot10^7$ of Bitcois in c circulation, we can conclude, that user should pay for about $6\cdot10^{-17}$ of total supply every block for every byte in output.

\subsection{Lost coins recirculation}
\label{sec:re}

The need of recirculating lost coins was widely discussed in cryptocurrencies \cite{gjermundrod2014recirculating, gjermundrod2016going} in order to combat deflation that will inevitably occur in cryptocurrencies with the fixed amount of coins to be circulated. Coins declared supply is known by cryptocurrency design, but available supply is unknown due to lost coins, locked in outputs that will never be spent \cite{ron2013quantitative}. On the other hand deflation is a real problem in the traditional monetary system, but it is still open question, whether it will also be a problem in the Bitcoin economy \cite{bitcoinDeflationarySpiral, barber2012bitter}.

While negative impact of deflation to cryptocurrencies is not proven, most of researchers agree in need of lost coins recirculating. \esse{} model provide lost coins recirculation mechanism by design, while it's properties vary from model implementation and parameters. In this section we are going to estimate lost coins recirculation dependency from chosen model and it's parameters.

Fee for keeping output of size \textit{BS} is the \state{} for \textit{LT} blocks is ${K \cdot BS \cdot LT}$. In \textit{Postpaid} and \textit{Leaking balance} models space-time fee is taken from output value itself, so when keys for output with \textit{$V_{output}$} coins are lost, they will return to economy after \textit{$LT_{max}$} blocks, where

\begin{equation}
{LT_{max} = {V_{output} \over K \cdot BS}}
\end{equation}

Maximum lifetime of a concrete outputs depends on miner-controlled \textit{K} parameter and user-defined output size and value. As in previous section we will estimate this dependency based on Bitcoin stats:

\begin{equation}
{LT_{max} \approx {1 \over 100 \cdot K}}
\end{equation}

Based on this equation, it is possible to chose \textit{K} keeping in mind desired maximum ouptut lifetime. Desiring 10 years period of coins fully recirculation, \textit{K} parameter should equals $10^{-6}$ that is much bigger than $10^{-9}$ from previous section \dnote{$??? 10 is too small, you'll be able to spend only hlaf of your money after 5 years$}. Regarding lost coins recirculation, significant difference between \textit{Postpaid} and \textit{Leaking balance} is that in \textit{Postpaid} all coins will return to economy all at once after some quite big $LT_{max}$ period, while in \textit{Leaking balance} they will return to economy by small portions during this period. This makes \textit{Leaking balance} preferable to \textit{Postpaid}, because lost coins from big enough outputs in \textit{Postpaid} will not return to the circulation in foreseeable future. Anyway in a log-term equilibrium conditions coins recirculation rate of both models will be calculated as

\begin{equation}
R_{postpaid} = R_{leaking} = {N_{lost} \cdot V_{output} \over LT_{max}} = {N_{lost} \cdot K \cdot BS}
\end{equation}

where $N_{lost}$ is the number of outputs with lost keys. Assuming current Bitcoins statistics and $N_{lost}\approx10^6$ we can estimate, that $\approx0.036$ BTC will be released from abandoned outputs keys every block.

In \textit{Prepaid} model user define $LT_{max}$ by himself when he creates output and number of released coins after $LT_{max}$ is equals to output value $V_{output}$ rater than much smaller space-time fee $fee_{space\_time}$. Note here, that $LT_{max}$ do not directly depends on \textit{K} and coins recirculation rate will only depend on $V_{output}$, user-defined $LT_{max}$ and number of lost outputs $N_{lost}$:

\begin{equation}
R_{prepaid} = {N_{lost} \cdot V_{output} \over LT_{max}}
\end{equation}

Let's assume user-defined coin recirculation period $LT_{max}\approx10$ years and $K\approx10^{-9}$ from previous section, we can estimate difference between prepaid and postpaid models:

\begin{equation}
{R_{prepaid} \over R_{postpaid}} = { V_{output}  \over  K \cdot BS \cdot LT_{max}} \approx 20
\end{equation}

%R_{postpaid} = R_{leaking} = {N_{lost} \cdot V_{output} \over LT_{max}} = {N_{lost} \cdot K \cdot BS} = 10^6 * 10^(-9) * 35 = 0.035
%R_{prepaid} = {N_{lost} \cdot V_{output} \over LT_{max}} = 10^(6) * 0.36 /  = 0.684931507
%  \item Mean number of coins in one output: $V_{output}=0.35$ BTC
%   \item Simple payment transaction fee: $fee_{propagation}=0.0002$ BTC

 \dnote{Check, should be something like 1000}

Thus \esse{} model by design provide a way to return lost coins to circulation, preventing deflation risks. \textit{Postpaid} model has a disadvantage, that lost coins will be returned to circulation in a far future, in \textit{Prepaid} model coin recirculation rate is much higher than in other models and \textit{Leaking balance} model is a smoother way of coin recirculation.

\subsection{Miner rewards}
\label{minerrew}
Mining reward is very important for cryptocurrency economy - in original paper \cite{Nakamoto2008} it's assumed, that miners are incentivized to fair behaviour, while recent researches showed, that it is not always correct \cite{carlsten2016instability, eyal2014}. In addition to usual propagation fee, \esse{} provides two new sources for miner income: a space-time fee and a coin recirculation reward.

\begin{equation}
R_{reward} = R_{propagation} + R_{space-time} + R_{recirculation}
\end{equation}

In section \ref{sec:flow} we have noticed, that \esse{} users have an incentive to actively use their coins and propagation reward is correlated with space-time reward:

\begin{equation}
R_{propagation} = M \cdot R_{space-time} + R_{pg}
\end{equation}

where $M$ and $C$ are non-negative constants. Space-time miner reward depends on \state{} size and space-time price $K$ only:

\begin{equation}
R_{space-time} = \sum_{i=1}^{N_{UTXO}} K_i \cdot BS_i \approx K \cdot N_{UTXO} \cdot BS
\end{equation}

Recirculation reward was calculated in previous section and depends on space-time fee model. However it can be generalized as with $K_{model}$ parameter, that is equals to 1 for \textit{Leaking balance} and \textit{Postpaid} models, and $K_{model} > 1$ \dnote{20?} for \textit{Prepaid} model:

\begin{equation}
R_{recirculation} = {K_{model} \cdot  N_{lost} \cdot K \cdot BS}
\end{equation}

Resulting miner reward:

\begin{equation}
\label{eq:reward}
R_{reward} \approx R_{pg} + (K \cdot BS) \cdot ((1 + M) \cdot N_{UTXO} + K_{model} \cdot N_{lost})
\end{equation}

First part of this equation $R_{pg}$ is the reward of miner in existing fee models, the rest is the unique reward for \esse{} model.  In a sensible assumption $N_{UTXO} >> N_{lost}$ equation \ref{eq:reward} can be simplified to

\begin{equation}
R_{postpaid} \approx R_{pg} + K \cdot BS \cdot N_{UTXO} \cdot (1 + M)
\end{equation}

that allows to estimate such $K$, when additional \esse{} reward will exceed common propagation reward $R_{pg}$:

\begin{equation}
K_{postpaid} = {R_{pg} \over BS \cdot N_{UTXO} \cdot (1 + M)} \approx 10^{-9} ({BTC / (Byte \cdot Block)})
\end{equation}

that is naturally coincide to estimations from section \ref{eq:ltmean} while both estimations are made from assumption, that propagation fee and space-time fee are equal for end users. Remarkable that space-time reward does not depend on network throughput and can be easily predicted. Since it will be accrued to generator of block with concrete height, it may be considered as a constant block reward fixing problem of blockchain instability without block reward \cite{carlsten2016instability}. It's value may be controlled by $K$ parameter making mining more stable and thus network more secure.

\dnote{What is an output value when miner is interested in collecting it?}

\subsection{Cryptocurrency inflation}

As we have already noticed in section \ref{minerrew}, miners reward from space-time fee can be considered as static block reward. Extending this idea it is possible to get rid of coinbase transactions breaking usual transaction rule that sum of inputs should not be less then sum of outputs. To achieve this, all coins should be issued in genesis block in such a way, that every block one output will be released and miner will collect it's value according space-time fee model. Thereafter miner will collect reward in uniform way collecting abandoned outputs, whenever it was created in genesis or by cryptocurrency user.

\subsection{Comparison with Gesell's money}

\dnote{Comparison with Gesell's money~(money with demurrage)}

\subsection{State size}

Finally, we are going to analize direct assignment of \esse{} model - to control \state{} size. Upper bound of \state{} size is $S$ may be easily calculated from assumption, that all available supply will be paid for space-time fee for one huge output to keep it in state for 1 block. However usually block size is limited by $S_{block}$ parameter and thus maximum output size is $BS = S_{block}$. As soon as each block space-time fee $K \cdot BS$ should be paid for all previously created outputs, maximum possible number of such outputs

\begin{equation}
O_{max} = {N_{coins} \over K \cdot S_{block}}
\end{equation}

and thus upper bound for state size is

\begin{equation}
S = {N_{coins} \over K}
\end{equation}

that is for about one petabyte \dnote{wtf?} for $K=10^{8}$.
% may be estimated for $K$ ~ 1.6*10^{7}

%moved miners will receive $S \cdot K$ coins per block.

\dnote{Max and expected state size}

%Another \esse{} feature, important for miners, is that it provides fee \textbf{mechanism to control state size}, preventing network centralization on a few amount of very powerful computers

\subsection{Subsidized space-time}

It is usual to pay for space-time multiplication for database leasing and thus \esse{} model is natural for blockchain-as-database model. On the other hand, in blockchain usage for currency it may be natural to allow users to keep some data for free in blockchain. In this section we are going to extend \esse{} model, subsidizing pre-defined by network space-time $S_s$ (which may also be defined by miners voting). For example, it may allow to keep simple money output for 10 years for free, subsidizing $S_s \approx 525600 (Blocks) \cdot 35 (Byte) \approx 18 (Mb \cdot Block)$. While 10 years is a quite big period for regular output, it is quite small amount of subsidized space-time for blockchain usage as a storage, e.g. will only allow to keep 127 Kb output for one date in \state{}.

Such subsidized fee may be calculated as

\begin{equation}
fee_{sub} = Max(0, K \cdot BS \cdot LT - S_s)
\end{equation}

and provides another way to control \esse{} economy with $S_s$ parameter. In particular it allows define $K$ and $S_s$ to archieve desired money flow and coin recirculation rates. As we have already noticed above $K$ parameter should be sufficiently different to archieve reasonable money flow and coin recirculation. It is possible to estimate $K$ and $S_s$ required for mean output lifetime $LT_{mean}$ and mean coin recirculation periods $R_{mean}$ using assumptions from previous sections:

\begin{equation}
  \begin{array}{ccl}
   K \cdot BS \cdot LT_{max} - S_s & = & V_{output} \\
   K \cdot BS \cdot LT_{mean} - S_s & = & fee_{propagation}
  \end{array}
\end{equation}

Assuming $LT_{mean}=1$ year and $LT_{max}=10$ years and Bitcoin statistics, we may estimate values of $K$ and $S_s$:

\begin{equation}
  \begin{array}{ccl}
   K & = & {V_{output} - fee_{propagation} \over BS \cdot (LT_{max} - LT_{mean})} \approx \quad 2*10^{-8} ({BTC / (Byte \cdot Block)}) \\
   S_s & = & {(V_{output} - fee_{propagation}) \cdot LT_{mean} \over (LT_{max} - LT_{mean})} - fee_{propagation} \approx 0.04\quad(BTC)
  \end{array}
\end{equation}

which is equals to 2 ($Mb \cdot Block$) for free.

Thus, additional subsidized space-time parameter allows to use one blockchain as both money and data chains. Subsidized value may be configured to be big enough for regular users, allowing them to keep their outputs for free for some time, but small enough for blockchain usage as database. It also allows to increase $K$ value painlessly for regular users, but increasing lost coin recirculation rate.

\dnote{transaction commission may be defined as $fee = Max(fee_{validation}, fee_{propagation}, fee_{space\_time})$}

\section{Related Work}

\section{Conclusion}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\end{document}
