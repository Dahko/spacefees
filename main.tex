\documentclass[]{llncs}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\usepackage{systeme}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{red}{Dima notes}}{#1}}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\esse}{\textit{SSE}}
\newcommand{\state}{\textit{State}}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}

\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\begin{document}

\title{On Space-Scarce Economy\\ In Blockchain Systems}
\author{Dmitry Meshkov \and Alexander Chepurnoy}
\institute{IOHK Research}
\maketitle

\begin{abstract}
In this paper we study space-scarce economy in massively replicated open blockchain systems, such as Bitcoin. In these systems memory to hold a state needed to validate transactions becomes the most scarce resource eventually. The issue is more critical for blockchain systems used to store data~(votes, certificates, logs etc.). Uncontrolled state size growth could lead to security issues, such as denial-of-service attacks. Only technical solutions, not economic, have been proposed to tackle this problem to the moment. In contrast, we propose to add a new component to a transaction fee scheme, which is a fee with a mandatory minimum based on how much additional space will be needed for new objects created in result of transaction processing, and for how long they will live in the state. We provide three possible options towards implementing the new fee component, namely \textit{prepaid outputs}, \textit{postpaid outputs} and \textit{scheduled payments}. We provide an analysis of the model with respect to all the three options. We show that the state growth could be bounded by a fee factor, miners are getting additional rewards, and lost coins are being taken back into circulation eventually.    
\end{abstract}

\section{Introduction}

Bitcoin \cite{Nakamoto2008} was introduced in 2008 by S. Nakamoto as a purely peer-to-peer version of electronic cash with a ledger written into a blockchain data structure maintained by the whole network. Security of the scheme is relied on a mining process. If a majority of miners is honest then Bitcoin meets its security goals as formal analysis~\cite{Garay2015} shows. For the work done a miner is claiming a reward which consists of two parts. First, some constant number of bitcoins are created out of thin air according to a predefined and hard-coded token emission schedule. Second, a miner claims fees for all the transactions included into the block. A transaction fee is set by a user during transaction creation.


A user pay fees to miners to have his transactions included into the blockchain. Fees are useful for an existing cryptocurrency economy for two reasons:

\begin{enumerate}
  \item{Incentivizing miner's activity. } A rational Bitcoin miner does not include all the valid transactions into blocks as, due to the increased chances of orphaning a block, the cost of adding transactions to a block could not be ignored~\cite{andersen2013,rizun2015transaction}. As shown in \cite{rizun2015transaction}, even in absence of block size limit, Bitcoin fee market is healthy and the miners surplus is maximized at a finite quantity of block space. Thus the miner is incentivized to produce a block of a limited size. This means that only a subset of transactions providing enough value to a miner will be included in a block. A paper~\cite{rizun2015transaction} provides a procedure to calculate transaction fee based on block propagation time, i.e. miners network resources utilization.

  \item{Limit resources usage and spam. } Besides of network utilization, transaction processing requires a miner to spend some computational resources. For most of cryptocurrencies, transactional language is limited \cite{script}, so a number of CPU cycles needed to process a transaction is bounded, and corresponding computational costs are not directly considered. In contrast, in cryptocurrencies supporting  smart contract languages, such as~\cite{seijas2016scripting,tezosScript,solidity}, transaction processing may require a lot of computations, and computational costs are included to transaction fees. This cost is specific to concrete transactional language and is out of scope of this paper.
\end{enumerate}

A transaction in Bitcoin spends outputs from previous transactions and creates new ones. A notable and the only exception is a coinbase transaction of a block which creates fixed amount of money out of thin air and also claims transaction fees without referring to any outputs~(a fee for an ordinary transaction is sum of claimed outputs values minus sum of values for created outputs). A node is checking a transaction in Bitcoin by using a set of unspent outputs. In other cryptocurrencies a representation of a \textit{state} needed to validate an arbitrary transaction could be different~(for example, in Ethereum~\cite{ethyp} such a structure is called the \textit{world state} and is a part of the protocol).  For fast validation, the state~(or most accessed part of it) should reside in random-access memory. Once it becomes too big to fit into RAM an attacker can perform denial-of-service attacks against cryptocurrency nodes. For example, during attacks on Ethereum in Autumn, 2016, an attacker added about 18 million accounts to the state~(whose size was less than 1 million accounts before the attack) and then performed succesful denial-of-service attacks against the nodes. Similarly, in 2013 a denial-of-service attack against output storage residing in a secondary storage~(HDD or SSD) was discovered in Bitcoin. 


The main purpose of this paper is to consider a new mandatory component for a transaction fee scheme reflecting state growth. In all known cryptocurrencies of today, a state element once created lives possibly forever without paying anything for that. This leads to continuously increasing state~(we point to the Bitcoin UTXO set size as to an example~\cite{utxoChart}). Moreover, state may grow fast during spam attack, for example, 15M additional outputs where introduced to Bitcoins UTXO during spam attacks in July 2015~\cite{bitcoin2015flood} and most of these outputs are not spent yet. The paper~\cite{reyzin2016improving} proposes a technical solution for non-mining nodes where only miners hold the full state~(assuming they can invest money in sufficiently big RAM storages) while other full-nodes are checking proofs of state transformations generated by miners, and size of a proof (in average and also in worst case) is about $log(S)$ in regards with a state size $S$. Nevertheless, big state could lead to centralization of mining or SPV mining~\cite{spvMining}, and these concerns should be addressed.
Also, there is an increasing demand to use a blockchain as a data storage, and storing permanently objects in the state without a cleaning procedure is not a viable option.

We propose an economic solution to the problem of unreasonable state growth (such as spam attacks or objects not being using anymore but living forever). The solution is a new mandatory fee component. We state that users should pay fee for both the state increasement and time new bytes will live in massively replicated storage of blockchain nodes for. This model is usual for cloud storage services where users pay for gigabyte of data per month. Such an approach prevents putting any data to the storage forever. Also miners can control their storage requirements by changing a fee factor. Later in this paper we will refer to the new fee component as to a \textit{space-time fee}.

Proposed fee regime is promoting money circulation in the blockchain economy. The limited lifetime of a state element also leads to lost coins being taken back into circulation~(by miners). 

Summarizing, we study an economy where memory of a massively-replicated system node becomes the most scarce resource eventually. Thus we call such an economy a \textit{space-scarce economy}. The model of it considered in this paper is called space-scarce economy, or \esse{}, model.

\knote{note that we're talking about minimal fees}

\subsection{Assumptions}
\begin{itemize}
  \item{} We assume that all the fees for a block are going to a single miner like in Bitcoin. There are proposals to share the rewards for a block within a group of miners~(for example, share fees with miners of some number of blocks before or after current one \cite{eyal2016bitcoin,kogias2016enhancing}). One difference is that in Bitcoin a miner can include his transactions into a block for free.
  \item{} We assume that a state consists of unspent outputs. An output is not modifiable so could be created and spent only. An output is protected by a script which is defined as a logical formula which can refer to properties of a blockchain (for example, its current height), spending transaction and an outputs itself. \knote{example} 
  \item{} For simplicity, we assume that a block is of a finite size but all the transactions a miner has at a given moment of time could be packed into it, if otherwise is not stated explicitly.
  \item{} Time is measured via notion of \textit{height} which is a number of blocks since an initial block~(a genesis block) till a particular one. 
  \item{} All anyone-can-spend outputs are collected by miners, presumably immediately as they appear.
\end{itemize}

\subsection{Structure of the Paper}

The paper is organized as follows. A design of our model is described in Section~\ref{sec:model}. The model is analyzed in Section~\ref{sec:analysis}.  
\knote{finish}


\section{The Model}
\label{sec:model}

In our model transaction fee $f$ consists of 3 parts: \textit{validation cost} $f_v$, \textit{propagation cost} $f_p$ and \textit{state space-time difference cost} $f_s$ and is non-negative value:

\begin{equation}
f = f_v + f_p + f_s , f \ge 0
\end{equation}

Validation and propagation costs are non-negative and assumed to be independent from the space-time fee. We assume that space-time fee impact to total fee $f$ may range from negligible to dominant. It is possible for $f_s$ to be negative since a transaction may whether increase or decrease the state. It depends on size of outputs to be marked as spent, newly created outputs and their time to live. If a transaction is freeing some space-time \textit{$T_{cleared}$} and claiming space-time \textit{$T_{filled}$}, then the  resulting space-time fee can be calculated as follows:
\begin{equation}
f_s = K \cdot (T_{filled} - T_{cleared})
\end{equation}

\knote{we need to say somehow here about prepaid and postpaid outputs defined below}

where \textit{K} is a space-time price. We assume that miners can change this price like they change ``gas'' cost in Ethereum~(based on hardware prices and token exchange rate) and thus control cost of maintaining the blockchain.

We consider three options for the fee to be charged. Concretely, \textit{prepaid outputs} are defined in Section~\ref{sec-prepaid}, \textit{postpaid outputs} are described in Section~\ref{sec-postpaid} and \textit{scheduled payments} are proposed in Section~\ref{sec-scheduled}.

\subsection{Prepaid Outputs}
\label{sec-prepaid}

First option we are going to analyze is prepaid outputs. Each output of a size \textit{B} in a state is prepaid for a duration $L_{max}$ set explicitly in a transaction creating the output. After $L_{max}$ anyone~(presumably a miner generating first block after that) is able to spend the overdue output. Thus a spending script for any output must be a combination of regular spending script and loan period $L_{max}$:

\begin{equation}
(Height > out.height + L_{max}) \lor (regular\_script)
\end{equation}

where \textit{Height} is current blockchain height and \textit{regular\_script} is user-defined spending script for the output\dnote{What is out.height?}. This form of a script is a part of consensus and a mandatory space-time fee is to be paid by a transaction creating the output:

\begin{equation}
f_{s-prepaid} = K \cdot (\sum_i{(B_i \cdot (L_{max\_i} - Height))} - \sum_j{(B_j \cdot (L_{max\_j} - Height)}))
\end{equation}

\knote{Height is subjective here, write about that}

\subsection{Postpaid Outputs}
\label{sec-postpaid}


In the second model a user should pay fee for consumed space-time when he spends an output. When an output is spent its lifetime is known so resulting transaction fee can be calculated as:

\begin{equation}
f_{s-postpaid} = \sum_i{(K_i \cdot B_i \cdot (H_{spent\_i} - H_{creation\_i}))}
\end{equation}

where $H_{creation\_i}$ and $H_{spent\_i}$ are heights where i-th output was created and spent respectively. Note that each output has its own space-time price \textit{$K_i$} which is the \textit{K} value at the time of the output creation. We note that for output value \textit{V} a height \textit{$H_{max}$} exists when the whole output value will be taken by the space-time fee:

\begin{equation}
H_{max} = {H_{creation} + {V \over {K \cdot B}}}
\end{equation}

After that anyone should be able to spend this output, sending the whole value to transaction fee and a spending script looks like

\begin{equation}
(Height > out.height + H_{max}) \lor (regular\_script)
\end{equation}
\dnote{TODO: space-time fee may be enforced by a script)}

\subsection{Scheduled Payments}
\label{sec-scheduled}

The last model we introduce is a combination of the prepaid and postpaid models. Like in the postpaid model, a user pays for an output when he spends it in a transaction. In addition, the output is also enforced to be moved before a known duration $D_{s}$ since its creation. That is, if the user do not move the coins before this then anyone can create a transaction claiming this output, returning all the coins back to the owner except of a space-time fee ${K \cdot B \cdot D_{s}}$. A spending script for the output would be like:

\begin{align}
\begin{split}
&(regular\_script) \lor \\
&(Height > (out.height + D_s) \land \\  
&\qquad has\_output(value = out.value - K \cdot B \cdot D_s, script = out.script))
\end{split}
\end{align}

In this model $D_s$ is another protocol parameter which may be fixed by a protocol design or changed via miners voting like \textit{K}.

\section{Analysis of the Model}
\label{sec:analysis}

In this section we provide analysis of the model. We show how the proposal is meeting its goal to control state size. We get estimations for additional miners
rewards as well as lost coins recirculation. Throughout this section we use following values got from current state of the Bitcoin network:

\begin{itemize}
  \item number of unspent transaction outputs: $N_{utxo} \approx 45,000,000$
  \item number of coins in circulation: $N_{coins} \approx 16,000,000$ BTC
  \item mean value of an output: $V_{mean} \approx 0.35$ BTC
  \item simple payment transaction fee: $f_{p} \approx 0.0002$ BTC
  \item mean output size: $B_{mean} \approx 36$ Bytes
  %\item share of coins moved in every block: $M_{flow} \approx 0.013$ \%
  \item time interval between blocks: $T_{block} \approx 10$ minutes
  \item transaction fees per block: $M_{pg} \approx 1$ BTC
  \item constant block reward: $M_c = 12.5$ BTC
  \item average number of outputs spent in a block $N_{moved} \approx 5,500$ 
\end{itemize}

We use the numbers from the Bitcoin to make calculations for some typical cases as this is the most used cryptocurrency with longest history. However, a cryptocurrency with SSE being deployed would have different values for the metrics. Thus results from this section got with the Bitcoin statistical data should be considered as initial.

We study money flows in a space-scarce economy while dividing them into two types. Miners claim lost coins and also charge every output in the system state every block. Users are incentivized to move coins more frequently thus increasing mining rewards due to increased economic activity.  

\subsection{Lost coins recirculation}
\label{sec:re}

The need of lost coins recirculation has been discussed in literature~\cite{gjermundrod2014recirculating,gjermundrod2016going} in regards with combat deflation that will inevitably occur in cryptocurrencies with fixed supply. Coins declared supply is known by cryptocurrency design, but available supply is not known due to lost coins locked in outputs that will never be spent~\cite{ron2013quantitative}. On the other hand, deflation is a real problem in the traditional monetary system, however, it is still an open question whether it will be problematic for the Bitcoin economy~\cite{bitcoinDeflationarySpiral,barber2012bitter}.


Our model provides lost coins recirculation mechanism by design while its properties vary from model implementation and parameters. In this section we study how lost coins recirculation depends from the both.

Fee for keeping output of size \textit{B} in the \state{} for \textit{L} blocks is ${K \cdot B \cdot L}$. In \textit{Postpaid} and \textit{Scheduled payments} models space-time fee is taken from output value itself so when keys for an output which value is \textit{$V_{output}$} are lost the coins will be taken back to circulation after \textit{$L_{max}$} blocks: 

\begin{equation}
{L_{max} = {V_{output} \over K \cdot B}}
\end{equation}

Maximum lifetime of a concrete output depends on the miner-controlled \textit{K} parameter and user-defined output size and value. For a typical case in Bitcoin:

\begin{equation}
{L_{max} \approx {1 \over 100 \cdot K}}
\end{equation}

From this equation it is possible to calcualte \textit{K} by specifying target maximum output lifetime. For example, in case of 50 years period of full recirculation for an output value \textit{K} parameter would be $10^{-9}$. Significant difference between \textit{Postpaid} and \textit{Scheduled payments} is that in \textit{Postpaid} all coins will return to economy all at once after potentially big $L_{max}$ period, while in the \textit{Scheduled payments} mode they will return to economy by portions during this period. This makes \textit{Scheduled payments} preferable to \textit{Postpaid} because lost coins from big enough outputs in \textit{Postpaid} will not return to the circulation in foreseeable future. Anyway coins recirculation rate for both the modes in a long-term would be calculated as

\begin{equation}
R_{postpaid} = R_{scheduled} = {N_{lost} \cdot V_{output} \over L_{max}} = {N_{lost} \cdot K \cdot B}
\end{equation}

where $N_{lost}$ is the number of outputs with lost keys. Assuming current Bitcoins statistics, $N_{lost}\approx10^6$ and $K = 10^{-9}$ we can estimate, that $\approx0.036$ bitcoin are to be released from abandoned outputs in every block.

In the \textit{Prepaid} mode a user defines $L_{max}$ by himself when he creates an output and number of released coins after $L_{max}$ is equals to output value $V_{output}$ rater than much smaller space-time fee $f_s$. Note here, that $L_{max}$ do not directly depends on \textit{K} and coins recirculation rate will only depend on $V_{output}$, user-defined $L_{max}$ and number of lost outputs $N_{lost}$:

\begin{equation}
R_{prepaid} = {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

Assuming that $K\approx10^{-9}$ we can estimate difference between prepaid and postpaid models:

\begin{equation}
{R_{prepaid} \over R_{postpaid}} = {V_{output} \over  K \cdot B \cdot L_{max}} \approx {10^7 \over L_{max}}
\end{equation}

For example, if user-defined coin recirculation period $L_{max}\approx10$ years then ${R_{prepaid} \over R_{postpaid}} \approx 19$

Concluding, \esse{} model by design provides a way to return lost coins to circulation thus preventing potential deflation. \textit{Postpaid} model has a disadvantage  that lost coins could be returned to circulation in far future. In \textit{Prepaid} model coin recirculation rate is presumably much higher than in other models and \textit{Scheduled payments} mode is a most smooth way to recycle coins.



\subsection{User-Driven Money flow}
\label{sec:flow}

From users point of view, the longer you keep some output, the bigger space-time fee you pay. Thus the proposed fee regime provides an incentive to move coins more frequently stimulating economic activity. In all the fee models introduced in Section~\ref{sec:model}, user pays ${K \cdot B}$ coins every block for keeping his output in the state. 


\ignore{
  If he uses blockchain with output size \textit{B} is relatively small and do not depend on output value.

  To estimate money flow let's assume, that user will move his money when space-time fee will start dominate over other transactional costs \dnote{why?}. Thus we can estimate expected mean output lifetime as

  \begin{equation}
  \label{eq:ltmean}
  L_{mean}={f_p \over K \cdot B}
  \end{equation}
}

Currently in Bitcoin $N_{moved}$ outputs are moved in a block, and this number can be defined as: 

\begin{equation}
N_{moved} = {N_{utxo} \over L_{mu}} % = {N_{utxo} \cdot K \cdot B \over f_p}
\end{equation}
where $L_{mu}$ is mean lifetime of an output. We can define $L_{mu}$ as:

\begin{equation}
L_{mu} = {N_{utxo} \over {N_{moved}}}
\end{equation}

In Bitcoin, $L_{mu} \approx 8182$ blocks.


With \esse{} fee component enabled users move coins more frequently, thus mean lifetime becomes $L_{mi} < L_{mu}$. It is hard to estimate $L_{mi}$ as it depends on K and also on blockchain-specific usage scenarios. Increasement in money flow could be calcualted as:

$\Delta N_{moved} = {N_{utxo} \over L_{mi}} - {N_{utxo} \over L_{mu}} = N_{utxo} \cdot {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}}$


\ignore{
  In the \textit{Scheduled payments} mode there is an additional component in the flow which is miners moving an output every $D_s$ blocks:

  \begin{equation}
    N_{scheduled} \approx {N_{utxo} \over D_s}
  \end{equation}



  We can find a ratio between $N_{incentivized}$ and ${moved}$:

  \begin{equation}
    r_{flow} = {N_{incentivized} \over N_{moved}}  \approx {8180 \over L_{max-mean}} % = {N_{utxo} \cdot K \cdot B \over f_p}
  \end{equation}

  For example, if a user pays for $8180$ blocks~(about 57 days) on average in the \textit{Prepaid} model, money flow doubles in comparison with a system without \esse{} component.  


  For \textit{Scheduled payments}:

  \begin{equation}
    r_{flow} = {{N_{incentivized} + N_{scheduled}} \over N_{moved}} % = {N_{utxo} \cdot K \cdot B \over f_p}
  \end{equation}
}

\ignore{
  and share of coins moved in a block:

  \begin{equation}
    M_{flow} \approx { N_{transactions} \cdot V_{output} \over N_{coins}} = {K \cdot B \over f_p}
  \end{equation}

  Thus, money flow may be controlled with \textit{K} parameter. This formula provide a way to estimate \textit{K} based on current Bitcoin statistics:

  \begin{equation}
    K={M_{flow} \cdot f_p \over B} \approx {10^{-9}} ({BTC / (Byte \cdot Block)})
  \end{equation}

  For a mean output size of 36 Bytes space-time fee part will exceed propagation fee after 5555 blocks or 38 days. 
  %This means, that for active users, who spend their money more often than once a month, space-time fee will be negligible relative to propagation fee.

  From money flow analysis we can find out how to use \esse{} model to control cryptocurrency money flow, changing space-time price and encourage active economy participants. Another money flow analysis result is the dependency between $L$ and $K$ \ref{eq:ltmean} that can particularly by used in the \textit{Scheduled payments} model to reduce number of model parameters.
}




\subsection{Miner rewards}
\label{minerrew}
Incentivizing mining is very important for viability of a cryptocurrency economy. 
In addition to usual propagation fee, \esse{} provides two new sources for miner income: a space-time fee and lost coins in the \textit{Prepaid} model.

Thus in the \textit{Prepaid} model:
\begin{equation}
M_{3} = M_{propagation} + M_{space-time} + M_{lost}
\end{equation}

In other models:
\begin{equation}
M_{2} = M_{propagation} + M_{space-time}
\end{equation}

We now calculate the difference with reward $M_{pg}$~(propagation fees) miners have in Bitcoin. We assume that number of inputs per transaction is the same, then number of transactions as well propagation fees are to be increased in the same way as $N_{moved}$:

\begin{equation}
M_{propagation} = M_{pg} \cdot(1 + {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}})
\end{equation}



\ignore{
  In Section \ref{sec:flow} we have noticed, that \esse{} users have an incentive to actively use their coins and propagation reward is correlated with space-time reward:

  \begin{equation}
    M_{propagation} = r_{flow} \cdot M_{space-time} + M_{pg}
  \end{equation}

  where $C$ is non-negative constant. 
}

A space-time reward depends on state size and space-time price $K$ only:

\begin{equation}
M_{space-time} = \sum_{i=1}^{N_{utxo}} K_i \cdot B_i \approx K \cdot N_{utxo} \cdot B
\end{equation}

Recirculation reward in the \textit{Prepaid} model:

%was calculated in previous section and depends on space-time fee model. However it can be generalized as with $K_{model}$ parameter, that is equals to 1 for \textit{Scheduled payments} and \textit{Postpaid} models, and $K_{model} \approx 20$ \dnote{$K_{model} is not used anywhere!$} for \textit{Prepaid} model:

\begin{equation}
M_{lost} = {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

Thus the additional mining reward is:

\begin{equation}
\Delta M_2 = M_2 - M_{pg} = M_{pg} \cdot {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}} + K \cdot N_{utxo} \cdot B
\end{equation}

\begin{equation}
\Delta M_3 = M_{pg} \cdot {{L_{mu}-L_{mi}} \over {L_{mu} \cdot L_{mi}}} + K \cdot N_{utxo} \cdot B + {N_{lost} \cdot V_{output} \over L_{max}}
\end{equation}

\ignore{
  \begin{equation}
  \label{eq:reward}
    M_{reward} \approx M_{pg} + (K \cdot B) \cdot ((1 + r_{flow}) \cdot N_{utxo} + r_{mode} \cdot N_{lost})
  \end{equation}

  First part of this equation $M_{pg}$ is the reward of miner in existing fee models, the rest is the unique reward for \esse{} model.  In a sensible assumption $N_{utxo} >> N_{lost}$ equation \ref{eq:reward} can be simplified to

  \begin{equation}
    M_{postpaid} \approx M_{pg} + K \cdot B \cdot N_{utxo} \cdot (1 + M)
  \end{equation}

  that allows to estimate such $K$, when additional \esse{} reward will exceed common propagation reward $M_{pg}$:

  \begin{equation}
    K = {M_{pg} \over B \cdot N_{utxo} \cdot (1 + M)} \approx 10^{-9} ({BTC / (Byte \cdot Block)})
  \end{equation}

  that is naturally coincide to estimations from section \ref{eq:ltmean} while miner reward equals to user losses.
}

We remark that space-time reward $K \cdot N_{utxo} \cdot B$ does not depend on network throughput and can be easily predicted. Since it will be accrued to generator of a block of a concrete height, and may be considered as a constant block reward. The reward value may be controlled by adjusting $K$ parameter making mining more stable and thus securing the network.

\subsection{State size}

In this section we analyze the main goal of \esse{} model which is to control state size. We study two most important cases. First, we estimate how big the state should be to give miners rewards comparable to Bitcoin's constant reward of today. Second, we study what is the maximum size of state could be considering a user having coins in the system and performing constant spam attack. \dnote{last sentense is not clean}

\paragraph{Constant Rewards}

For a state of size $S$ miner is getting $S \cdot K$ space-time fees every block. For them to be a replacement for the current constant reward in Bitcoin $M_c$ following equality should hold:

\begin{equation}
\label{eq:statesizeexp}
S \cdot K = M_c
\end{equation}
which leads to 13 Gb state for $K=10^{-9}$ ($BTC / (Byte \cdot Block)$).


\paragraph{Spam Attack}

We consider an attacker who creates an output roughly of size of a block $S_{block}$ for every block in a row. Initially the attacker has all the $N_{coins}$ of the system and he does not buy new coins during the attack~(miners do not sell the coins to him). We also assume that $K$ is constant during the attack~(however, in real world miner would likely raise $K$ during the attack). As soon as each block space-time fee $K \cdot B$ should be paid for all previously created outputs, maximum possible number of such outputs $O_{max}$ is to be calculated from equation:

\begin{equation}
%N_{coins} = \sum_i^{O_{max}}{K \cdot S_{block} \cdot i} = K \cdot S_{block} \cdot ( O_{max}^2 + O_{max}) / 2 \approx K \cdot S_{block} \cdot O_{max}^2 / 2
N_{coins} = \sum_i^{O_{max}}{K \cdot S_{block} \cdot i} \approx K \cdot S_{block} \cdot O_{max}^2 / 2
\end{equation}
assuming that number of unspent outputs is big enough. Resulting state size: 

\begin{equation}
\label{eq:statesizemax}
S = S_{block} \cdot O_{max} = \sqrt { 2 \cdot N_{coins} \cdot S_{block} \over K}
\end{equation}
which is about 183 gigabytes for Bitcoin statistics and $K=10^{-9}$ ($BTC / (Byte \cdot Block)$). Taking into account that \state{} should be kept in memory, 183GB is quite big state size, however, miners can keep it in RAM. Note also that it is upper-bound of \state{} size calculated from non-realistic assumptions that all available supply will be paid for space-time fee, and $K$ is constant.

Thus \esse{} model allows to control state growth with $K$ parameter and allows to estimate expected state size as well as an upper bound. Reasonable $K$ value leads to 13 Gb of expected state size and 183 GB for a spam attack backed by all the tokens in the system. The model is preventing spam attacks like \cite{bitcoin2015flood} and provide a guarantee that miners can have state fit in RAM.

\section{Related Work}

Ethereum\cite{ethyp} introduced a fee to cover computational costs of nodes processing a transaction~(via rewarding a miner), with a mandatory minimum. A price of a computational unit~(which is an instruction of Ethereum Virtual Machine) is controlled by miners via adjusting ``gas'' price. We consider to adopt this approach toward charging users for consuming space-time units.

FreiCoin\cite{freicoin} is a cryptocurrency with demurrage. Demurrage-adjusted running balance~(aggregated for all the outputs associated with a key) is to be recalculated when a transaction is touching any output which is a part of the balance. Unlike FreiCoin, miners are watching over the state constantly to clean it in our proposal, and coins being lost are getting back into circulation~(in FreiCoin, outputs forgotten do live forever in the unspent outputs set).

In PascalCoin \cite{pascalCoin}, if an account has not made any operations for 420,480 blocks then its balance is considered as forgotten and miner can claim it. Our approach to recover lost coins is more natural. In the \textit{prepaid} mode a user sets expiration time on his side~(paying accordingly), in \textit{postpaid} and \textit{scheduled payments} modes a forgotten output is to be turned into space-time fees eventually.

\section{Further Work}

We left some questions for further research:

\begin{itemize}
  \item{}it is interesting to see how tokens in a cryptocurrency with a \esse{} fee component can be compared with a Gesell's demurrage currency\cite{gesell1958natural}.
  \item{}an interesting research vector is how to find appropriate mandatory minimal $f_v$, $f_p$, $f_s$ values. Another question is how these component could be combined in a transaction fee $f$. One possible option is to set $f = max(f_p, f_v, f_s)$.
  \item{}concrete dependency of space-time fee from output size and lifetime is another topic of discussion. One possible option is discussed in Appendix \ref{sec:subsidy}.
  \item{}a possible interaction with the problem of blockchain instability without the constant block reward~\cite{carlsten2016instability} in the setting of increased fee supply is another concern to study.
\end{itemize}

\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}

\appendix

\section{On Subsidizing Space-time}
\label{sec:subsidy}

It is usual to pay space-time fee for a cloud storage and thus \esse{} model is natural for a blockchain acting as a database. On the other hand, in a cryptocurrency setting it may be natural to allow users to keep their coins for free for some period of time $S_s/B$. For example $S_s \approx 1.8$ ($Mb \cdot Block$) will allow to keep output for free for one year assuming 10 minutes block interval. While it is quite a big period for regular output, it is negligible for blockchain usage as a storage, e.g. will only allow to keep 12 Kb output for one day in \state{}.

For sure, this free space time will increase \state{} size upper bound. To maximize attack damage, the adversary will maximize number of created outputs, getting $S_s$ space-time for each for free, filling all blocks during subsidized period $S_s/B$. In case of Bitcoin parameters one year of subsidized period for smallest outputs will make it possible to keep 51 Gb of outputs for free, increasing \state{} size upper bound for 27\%.

Thus, additional subsidized space-time parameter allows to use the same blockchain for both money and data applications. Also this additional parameter provide a new way to configure cryptocurrency, for example to increase $K$ value painlessly for regular users, but increasing lost coin recirculation rate.

\section{Examples}

\knote{moneychain and datachain}

\section{Unified Transactions}

\knote{We can throw away specially coinbase transactions getting unified transaction format, by requiring fees to be paid in form of anyone-can-spend output, and by creating constant rewards in predefined and hard-coded pre-genesis state, where a reward for a certain height is an output in the pre-genesis UTXO spendable only at this height.}

\section{Questions and Answers}


\paragraph{\textbf{Q: } Aren't there important use-cases for ``storing data forever''? Like when the ledger is used for storing property deeds or university degrees or other public, "official" documents?}~\\
\textbf{A: } While this is very appealing for a user to store something forever paying just once~(or not paying anything at all), a resulting economy where miners need to store increasingly growing amount of data getting bounded rewards may be unstable or just not viable. As a solution, we propose a system where a state size could be bounded, then, as new data is to be introduced each block, expiration is strictly needed. However, for some real-life scenarios we can imagine hybrid systems, where some special actors~(governments or universities) can store something forever~(paying once, or not paying at all), while other participants are paying as we are proposing thus subsidizing public good.

\paragraph{\textbf{Q: } If the miner can fully control K, how do you prevent a miner from setting K VERY high? Should not there be some sort of guarantee about the minimum value of $L_{max}$ BEFORE a transaction is made?}~\\
\textbf{A: } We assume miners will behave rationally, so they do not want to kill the business by setting $K$ high. We propose to have a rule for changing $K$ slowly, as in Ethereum~(where a miner can increase or decrease gas price by 1\% per block) so $L_max$ could be estimated before the transaction being made with a good precision.


\end{document}
